src/NodeToken.h:4234:17: error: Using object that points to local variable '__f' that is out of scope. [invalidLifetime]
            c = __num & 0xff;
                ^
src/NodeToken.h:4228:46: note: Address of variable taken here.
            __num = (uint32_t)(*((uint32_t *)&__f));
                                             ^
src/NodeToken.h:4226:19: note: Variable created here.
            float __f = 0;
                  ^
src/NodeToken.h:4234:17: note: Using object that points to local variable '__f' that is out of scope.
            c = __num & 0xff;
                ^
src/NodeToken.h:4237:21: error: Using object that points to local variable '__f' that is out of scope. [invalidLifetime]
            __num = __num / 256;
                    ^
src/NodeToken.h:4228:46: note: Address of variable taken here.
            __num = (uint32_t)(*((uint32_t *)&__f));
                                             ^
src/NodeToken.h:4226:19: note: Variable created here.
            float __f = 0;
                  ^
src/NodeToken.h:4237:21: note: Using object that points to local variable '__f' that is out of scope.
            __num = __num / 256;
                    ^
src/NodeToken.h:4045:26: warning: Either the condition 'i>-1' is redundant or the array 'v->sizes[20]' is accessed at index -1, which is out of bounds. [negativeIndex]
        start += v->sizes[i];
                         ^
src/NodeToken.h:4037:15: note: Assuming that condition 'i>-1' is not redundant
        if (i > -1)
              ^
src/NodeToken.h:4045:26: note: Negative array index
        start += v->sizes[i];
                         ^
src/string_function.h:42:15: information: --check-library: There is no matching configuration for function std::string() [checkLibraryFunction]
  return std::string(buf.get(),
              ^
src/asm_struct_enum.h:171:27: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
      _it = _texts.insert(next(_it), m);
                          ^
src/asm_struct_enum.h:177:14: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      return string(_texts.back());
             ^
src/asm_struct_enum.h:181:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
  string current() { return string(*_it); }
                            ^
src/asm_struct_enum.h:183:15: information: --check-library: There is no matching configuration for function findText() [checkLibraryFunction]
    int pos = findText(" ");
              ^
src/asm_struct_enum.h:196:14: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      return string(_texts.front());
             ^
src/asm_struct_enum.h:202:14: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      return string(_texts[pos]);
             ^
src/asm_struct_enum.h:226:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      if (s.compare(string(*_it)) == 0) {
                    ^
src/tokenizer.h:716:11: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
      if (next(it) == script.end()) {
          ^
src/tokenizer.h:721:14: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
        it = next(it);
             ^
src/NodeToken.h:26:3: information: --check-library: There is no matching configuration for function ESP_LOGD() [checkLibraryFunction]
  ESP_LOGD("ESPLiveScript", "%s\r\n", str.c_str());
  ^
src/NodeToken.h:125:36: information: --check-library: There is no matching configuration for function uxTaskGetStackHighWaterMark() [checkLibraryFunction]
  UBaseType_t stackHighWaterMark = uxTaskGetStackHighWaterMark(loopTaskHandle);
                                   ^
src/NodeToken.h:143:22: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
void displayStat() { displayStat(""); }
                     ^
src/NodeToken.h:155:36: information: --check-library: There is no matching configuration for function uxTaskGetStackHighWaterMark() [checkLibraryFunction]
  UBaseType_t stackHighWaterMark = uxTaskGetStackHighWaterMark(loopTaskHandle);
                                   ^
src/NodeToken.h:681:13: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        if (string(getTargetText()).compare(0, 1, "@") == 0) {
            ^
src/NodeToken.h:684:17: information: --check-library: There is no matching configuration for function findMember() [checkLibraryFunction]
        int i = findMember(_vartype, string(getTargetText()));
                ^
src/NodeToken.h:684:38: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        int i = findMember(_vartype, string(getTargetText()));
                                     ^
src/NodeToken.h:713:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        int cmp = getChildAtPos(2)->getChildAtPos(i)->findMaxArgumentSize();
                                    ^
src/NodeToken.h:1207:38: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        if (extvariablestore.compare(string(v.getTokenText())) != 0) {
                                     ^
src/NodeToken.h:1211:28: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        extvariablestore = string(v.getTokenText());
                           ^
src/NodeToken.h:1231:38: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        if (extvariablestore.compare(string(v.getTokenText())) != 0) {
                                     ^
src/NodeToken.h:1235:28: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        extvariablestore = string(v.getTokenText());
                           ^
src/NodeToken.h:1413:11: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    res = string(p->getTargetText());
          ^
src/NodeToken.h:1566:16: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    } else if (string(nd->getTokenText()).find("x") != string::npos) {
               ^
src/NodeToken.h:2043:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string sd = string(nd->getTargetText());
                ^
src/NodeToken.h:2436:33: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          nd->getChildAtPos(1)->getChildAtPos(i)->getVarType()->total_size);
                                ^
src/NodeToken.h:2615:24: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      content.addAfter(string(_div[i]));
                       ^
src/NodeToken.h:2966:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
  nd->setTargetText(string(nd->parent->getTargetText()));
                    ^
src/NodeToken.h:3100:33: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      if (nd->getChildAtPos(1)->getChildAtPos(0)->_nodetype == numberNode) {
                                ^
src/NodeToken.h:3102:47: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        f = stringToInt(nd->getChildAtPos(1)->getChildAtPos(0)->getTokenText());
                                              ^
src/NodeToken.h:3207:33: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      if (nd->getChildAtPos(1)->getChildAtPos(0)->_nodetype == numberNode) {
                                ^
src/NodeToken.h:3209:47: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        f = stringToInt(nd->getChildAtPos(1)->getChildAtPos(0)->getTokenText());
                                              ^
src/NodeToken.h:3360:33: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      if (nd->getChildAtPos(0)->getChildAtPos(j)->findMaxArgumentSize() - 1 >=
                                ^
src/NodeToken.h:3381:30: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
    if (t->getChildAtPos(0)->getChildAtPos(i)->isPointer) {
                             ^
src/NodeToken.h:3383:29: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                            ^
src/NodeToken.h:3396:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        if (func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType ==
                                    ^
src/NodeToken.h:3402:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType);
                                    ^
src/NodeToken.h:3403:31: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                              ^
src/NodeToken.h:3408:31: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                              ^
src/NodeToken.h:3411:33: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      if (nd->getChildAtPos(0)->getChildAtPos(i)->getVarType() != NULL and
                                ^
src/NodeToken.h:3415:35: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            nd->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType,
                                  ^
src/NodeToken.h:3422:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType;
                                    ^
src/NodeToken.h:3425:36: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
              t->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType;
                                   ^
src/NodeToken.h:3438:34: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            t->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType;
                                 ^
src/NodeToken.h:3458:19: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                ->getChildAtPos(i)
                  ^
src/NodeToken.h:3486:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                                  ->getChildAtPos(i)
                                    ^
src/NodeToken.h:3497:21: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                  ->getChildAtPos(i)
                    ^
src/NodeToken.h:3511:21: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                  ->getChildAtPos(i)
                    ^
src/NodeToken.h:3524:28: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                         ->getChildAtPos(i)
                           ^
src/NodeToken.h:3531:56: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                                                     ->getChildAtPos(i)
                                                       ^
src/NodeToken.h:3540:56: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                                                     ->getChildAtPos(i)
                                                       ^
src/NodeToken.h:3545:28: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                         ->getChildAtPos(i)
                           ^
src/NodeToken.h:3589:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          v = func->getChildAtPos(1)->getChildAtPos(i)->getVarType();
                                      ^
src/NodeToken.h:3591:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          v = nd->getChildAtPos(0)->getChildAtPos(i)->getVarType();
                                    ^
src/NodeToken.h:3644:35: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      if (func->getChildAtPos(1)->getChildAtPos(i)->isPointer) {
                                  ^
src/NodeToken.h:3648:31: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                              ^
src/NodeToken.h:3651:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->stack_pos - _STACK_SIZE;
                                    ^
src/NodeToken.h:3675:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType);
                                    ^
src/NodeToken.h:3678:31: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                              ^
src/NodeToken.h:3682:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->stack_pos - _STACK_SIZE +
                                    ^
src/NodeToken.h:3683:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->total_size;
                                    ^
src/NodeToken.h:3685:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size - 1;
                                    ^
src/NodeToken.h:3687:42: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
             j < func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size;
                                         ^
src/NodeToken.h:3690:37: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          if (nd->getChildAtPos(0)->getChildAtPos(i)->getVarType() != NULL) {
                                    ^
src/NodeToken.h:3693:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                nd->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType,
                                      ^
src/NodeToken.h:3704:26: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                       ->getChildAtPos(i)
                         ^
src/NodeToken.h:3708:43: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                                        ->getChildAtPos(i)
                                          ^
src/NodeToken.h:3727:41: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size -
                                        ^
src/NodeToken.h:3746:41: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size -
                                        ^
src/NodeToken.h:3845:33: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
  switch (nd->getChildAtPos(1)->getChildAtPos(0)->type) {
                                ^
src/NodeToken.h:3848:27: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
    nd->getChildAtPos(1)->getChildAtPos(0)->type =
                          ^
src/NodeToken.h:3853:27: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
    nd->getChildAtPos(1)->getChildAtPos(0)->type = TokenNotEqual;
                          ^
src/NodeToken.h:3856:27: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
    nd->getChildAtPos(1)->getChildAtPos(0)->type = TokenDoubleEqual;
                          ^
src/NodeToken.h:3859:27: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
    nd->getChildAtPos(1)->getChildAtPos(0)->type = TokenLessThan;
                          ^
src/NodeToken.h:3862:27: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
    nd->getChildAtPos(1)->getChildAtPos(0)->type = TokenLessOrEqualThan;
                          ^
src/NodeToken.h:3865:27: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
    nd->getChildAtPos(1)->getChildAtPos(0)->type = TokenMoreThan;
                          ^
src/NodeToken.h:3933:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string sd = string(nd->getTargetText());
                    ^
src/NodeToken.h:4212:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      string str = string(nd->getChildAtPos(0)->getTokenText());
                   ^
src/NodeToken.h:4404:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string sd = string(nd->getTargetText());
                ^
src/NodeToken.h:4584:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string sd = string(nd->getTargetText());
                ^
src/NodeToken.h:4754:29: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
  if (nd->getChildAtPos(0)->getChildAtPos(0)->_nodetype != numberNode) {
                            ^
src/NodeToken.h:4849:19: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
  string target = string(nd->getTokenText());
                  ^
src/NodeToken.h:4903:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      string tmp = string((*text->getChildAtPos(i)));
                   ^
src/NodeToken.h:4966:18: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string tmp = string((*text->getChildAtPos(i)));
                 ^
src/NodeToken.h:5005:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      string tmp = string((*text->getChildAtPos(i)));
                   ^
src/NodeToken.h:5050:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      string tmp = string((*text->getChildAtPos(i)));
                   ^
src/NodeToken.h:5429:18: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string tmp = string((*text->getChildAtPos(i)));
                 ^
src/NodeToken.h:5444:18: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string tmp = string((*text->getChildAtPos(i)));
                 ^
src/NodeToken.h:5449:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
          tmp = string((*text->getChildAtPos(i - 1)));
                ^
src/NodeToken.h:5461:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
          tmp = string((*text->getChildAtPos(i - 1)));
                ^
src/NodeToken.h:5474:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
          tmp = string((*text->getChildAtPos(i - 1)));
                ^
src/asm_parser.h:447:16: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      if (trim(string((*it)->getText())).compare(trim(s)) == 0) {
               ^
src/asm_parser.h:483:19: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    if (findLabel(string(res.getText()), asm_parsed) != -1) {
                  ^
src/asm_parser.h:945:27: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    int index = findLabel(string(ps.getText()), asm_parsed);
                          ^
src/asm_parser.h:971:27: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    int index = findLabel(string(ps.getText()), asm_parsed);
                          ^
src/asm_parser.h:1213:3: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
  displayStat("before mem");
  ^
src/asm_parser.h:1217:3: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
  displayStat("after mem");
  ^
src/asm_parser.h:1431:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLabel(string(parse_line->getText()), asm_parsed);
                            ^
src/asm_parser.h:1595:40: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      vector<string> args = split(trim(string((*it2)->getText())), " ");
                                       ^
src/asm_parser.h:1600:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLabel(string((*it)->getText()), asm_parsed);
                            ^
src/asm_parser.h:1605:30: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string stackstring = string((*it)->getText()).insert(2, "stack_");
                             ^
src/asm_parser.h:1652:3: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
  displayStat("before call parsem");
  ^
src/asm_parser.h:1690:18: information: --check-library: There is no matching configuration for function fs::FS::open() [checkLibraryFunction]
  File root = fs.open(name, FILE_WRITE);
                 ^
src/asm_parser.h:1691:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)"ESPLiveScript1.0.1", 19);
       ^
src/asm_parser.h:1692:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->tmp_instruction_size, 2);
       ^
src/asm_parser.h:1695:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->instruction_size, 2);
       ^
src/asm_parser.h:1698:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->data_size, 2);
       ^
src/asm_parser.h:1701:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->function_size, 2);
       ^
src/asm_parser.h:1704:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write(bin->binary_data, bin->tmp_instruction_size);
       ^
src/asm_parser.h:1705:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write(bin->function_data, bin->function_size);
       ^
src/execute_asm.h:32:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(bin->binary_data);
    ^
src/execute_asm.h:34:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(bin->function_data);
    ^
src/execute_asm.h:86:28: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLink(string(textptr).substr(6, 100), externalType::value);
                           ^
src/execute_asm.h:116:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
          findLink(string(textptr).substr(2, 100), externalType::function);
                   ^
src/execute_asm.h:159:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      gc.name = string(textptr);
                ^
src/execute_asm.h:164:22: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      gc.variables = string(textptr);
                     ^
src/execute_asm.h:216:19: information: --check-library: There is no matching configuration for function heap_caps_malloc() [checkLibraryFunction]
      (uint32_t *)heap_caps_malloc(bin->instruction_size, MALLOC_CAP_EXEC);
                  ^
src/execute_asm.h:318:18: information: --check-library: There is no matching configuration for function fs::FS::open() [checkLibraryFunction]
  File root = fs.open(name);
                 ^
src/execute_asm.h:321:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)ver, 19);
       ^
src/execute_asm.h:329:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->tmp_instruction_size, 2);
       ^
src/execute_asm.h:332:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->instruction_size, 2);
       ^
src/execute_asm.h:335:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->data_size, 2);
       ^
src/execute_asm.h:338:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->function_size, 2);
       ^
src/execute_asm.h:343:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read(tmp, bin->tmp_instruction_size);
       ^
src/execute_asm.h:346:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read(tmp2, bin->function_size);
       ^
src/execute_asm.h:523:5: information: --check-library: There is no matching configuration for function heap_caps_aligned_free() [checkLibraryFunction]
    heap_caps_aligned_free(ex->start_program);
    ^
src/execute_asm.h:530:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(ex->data);
    ^
src/execute.h:66:3: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
  vTaskDelay(1);
  ^
src/execute.h:108:9: information: --check-library: There is no matching configuration for function vTaskSuspend() [checkLibraryFunction]
        vTaskSuspend(__run_handles[i]);
        ^
src/execute.h:117:9: information: --check-library: There is no matching configuration for function vTaskResume() [checkLibraryFunction]
        vTaskResume(__run_handles[i]);
        ^
src/execute.h:128:5: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
    xEventGroupSync(xCreatedEventGroup, MASK, MASK, portMAX_DELAY);
    ^
src/execute.h:129:5: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
    vTaskDelay(10);
    ^
src/execute.h:130:5: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
    xEventGroupSync(xCreatedEventGroup2, MASK, MASK, portMAX_DELAY);
    ^
src/execute.h:193:14: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
  uxReturn = xEventGroupSync(xCreatedEventGroup, 1 << h, MASK, portMAX_DELAY);
             ^
src/execute.h:199:7: information: --check-library: There is no matching configuration for function xEventGroupClearBits() [checkLibraryFunction]
      xEventGroupClearBits(xCreatedEventGroup, MASK);
      ^
src/execute.h:209:7: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
      xEventGroupSync(xCreatedEventGroup2, 1 << h, MASK, portMAX_DELAY);
      ^
src/execute.h:215:7: information: --check-library: There is no matching configuration for function xEventGroupClearBits() [checkLibraryFunction]
      xEventGroupClearBits(xCreatedEventGroup2, MASK);
      ^
src/execute.h:218:5: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
    xEventGroupSync(xCreatedEventGroup2, 1 << h, MASK, portMAX_DELAY);
    ^
src/execute.h:313:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(10);
      ^
src/execute.h:315:9: information: --check-library: There is no matching configuration for function vTaskSuspend() [checkLibraryFunction]
        vTaskSuspend(*runningPrograms.getHandleByIndex(__run_handle_index));
        ^
src/execute.h:320:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(10);
      ^
src/execute.h:336:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(10);
      ^
src/execute.h:337:7: information: --check-library: There is no matching configuration for function vTaskResume() [checkLibraryFunction]
      vTaskResume(*runningPrograms.getHandleByIndex(__run_handle_index));
      ^
src/execute.h:352:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(10);
      ^
src/execute.h:358:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(30);
      ^
src/execute.h:361:9: information: --check-library: There is no matching configuration for function vTaskDelete() [checkLibraryFunction]
        vTaskDelete(*runningPrograms.getHandleByIndex(__run_handle_index));
        ^
src/execute.h:365:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(30);
      ^
src/execute.h:371:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(10);
      ^
src/execute.h:411:7: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
      vTaskDelay(20);
      ^
src/execute.h:429:7: information: --check-library: There is no matching configuration for function xTaskCreateUniversal() [checkLibraryFunction]
      xTaskCreateUniversal(
      ^
src/execute.h:625:3: information: --check-library: There is no matching configuration for function vTaskDelete() [checkLibraryFunction]
  vTaskDelete(NULL);
  ^
src/ESPLiveScript.h:205:5: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
    displayStat("afterclen");
    ^
src/ESPLiveScript.h:447:23: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
          string sd = string(current_node->getTargetText());
                      ^
src/ESPLiveScript.h:491:13: information: --check-library: There is no matching configuration for function findMember() [checkLibraryFunction]
        i = findMember(current_node->getVarType(),
            ^
src/ESPLiveScript.h:492:24: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                       string(current()->getText()));
                       ^
src/ESPLiveScript.h:503:48: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        i = findMember(current_node->_vartype, string(current()->getText()));
                                               ^
src/ESPLiveScript.h:547:18: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
      current()->addText(
                 ^
src/ESPLiveScript.h:589:13: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          ->getChildAtPos(0)
            ^
src/ESPLiveScript.h:615:34: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
    current_node = current_node->addChild(NodeToken(inputArgumentsNode));
                                 ^
src/ESPLiveScript.h:795:26: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                         string(sav_t.back().getText())) == 0) {
                         ^
src/ESPLiveScript.h:914:44: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
      if (search_result->getChildAtPos(1)->getChildAtPos(i)->_vartype ==
                                           ^
src/ESPLiveScript.h:953:34: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
    current_node = current_node->addChild(NodeToken(current(), comparatorNode));
                                 ^
src/ESPLiveScript.h:976:19: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
    current_node->addChild(NodeToken(statementNode));
                  ^
src/ESPLiveScript.h:979:21: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node->addChild(NodeToken(current(), stringNode));
                    ^
src/ESPLiveScript.h:992:23: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node->addChild(NodeToken(c, breakNode));
                      ^
src/ESPLiveScript.h:1011:23: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node->addChild(NodeToken(c, continueNode));
                      ^
src/ESPLiveScript.h:1023:23: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node->addChild(NodeToken(returnNode));
                      ^
src/ESPLiveScript.h:1027:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(returnNode));
                                     ^
src/ESPLiveScript.h:1102:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(assignementNode));
                                   ^
src/ESPLiveScript.h:1108:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(unitaryOpNode));
                                   ^
src/ESPLiveScript.h:1138:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(assignementNode));
                                   ^
src/ESPLiveScript.h:1213:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(binOpNode));
                                     ^
src/ESPLiveScript.h:1296:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(
                                   ^
src/ESPLiveScript.h:1344:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(
                                     ^
src/ESPLiveScript.h:1412:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(
                                     ^
src/ESPLiveScript.h:1479:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(
                                     ^
src/ESPLiveScript.h:1482:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(statementNode));
                                     ^
src/ESPLiveScript.h:1511:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(statementNode));
                                     ^
src/ESPLiveScript.h:1639:22: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
          current()->addText(string_format(
                     ^
src/ESPLiveScript.h:1677:25: information: --check-library: There is no matching configuration for function Context::findVariable() [checkLibraryFunction]
          current_cntx->findVariable(nodeTokenList.get().getTokenText(), false);
                        ^
src/ESPLiveScript.h:1689:22: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
          current()->addText(string_format(
                     ^
src/ESPLiveScript.h:1731:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(assignementNode));
                                     ^
src/ESPLiveScript.h:1831:23: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node->addChild(NodeToken(current(), blockStatementNode));
                      ^
src/ESPLiveScript.h:1866:34: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
    current_node = current_node->addChild(NodeToken(defInputArgumentsNode));
                                 ^
src/ESPLiveScript.h:2168:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(ternaryIfNode));
                                   ^
src/ESPLiveScript.h:2202:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(binOpNode));
                                   ^
src/ESPLiveScript.h:2245:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(binOpNode));
                                   ^
src/ESPLiveScript.h:2296:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(testNode));
                                   ^
src/ESPLiveScript.h:2356:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(binOpNode));
                                   ^
src/ESPLiveScript.h:2404:21: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node->addChild(NodeToken(current(), numberNode));
                    ^
src/ESPLiveScript.h:2431:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(unitaryOpNode));
                                   ^
src/ESPLiveScript.h:2457:25: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
          current_node->addChild(NodeToken(current(), changeTypeNode));
                        ^
src/ESPLiveScript.h:2584:18: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
      current()->addText(
                 ^
src/ESPLiveScript.h:2591:13: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
          ->getChildAtPos(2)
            ^
src/ESPLiveScript.h:2617:36: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      current_node = current_node->addChild(NodeToken(current(), numberNode));
                                   ^
src/ESPLiveScript.h:2680:34: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
      program.addChildFront(nd)->addChild(NodeToken(current(), stringNode));
                                 ^
src/ESPLiveScript.h:2778:37: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
          sizestr = sizestr + " " + string(current()->getText());
                                    ^
src/ESPLiveScript.h:2793:39: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            sizestr = sizestr + " " + string(current()->getText());
                                      ^
src/ESPLiveScript.h:2898:26: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
              current()->addText(string_format("%s._@%s", usded.varName.c_str(),
                         ^
src/ESPLiveScript.h:2916:26: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
              current()->addText(string_format("%s.%s", usded.varName.c_str(),
                         ^
src/ESPLiveScript.h:3022:18: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        j.json = string(current()->getText());
                 ^
src/ESPLiveScript.h:3044:22: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        j.variable = string(current()->getText());
                     ^
src/ESPLiveScript.h:3126:28: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                current()->addText(string_format(
                           ^
src/ESPLiveScript.h:3144:29: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
              current_node->addChild(NodeToken(current(), stringNode));
                            ^
src/ESPLiveScript.h:3205:26: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
              current()->addText(string_format(
                         ^
src/ESPLiveScript.h:3245:44: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
              current_node = current_node->addChild(NodeToken(assignementNode));
                                           ^
src/asm_struct_enum.h:62:5: information: --check-library: There is no matching configuration for function push() [checkLibraryFunction]
    push(sav + 1);
    ^
src/asm_struct_enum.h:70:5: information: --check-library: There is no matching configuration for function push() [checkLibraryFunction]
    push(sav - 1);
    ^
src/asm_struct_enum.h:472:3: warning: Member variable 'result_parse_line::bincode' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:472:3: warning: Member variable 'result_parse_line::size' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:472:3: warning: Member variable 'result_parse_line::op' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:472:3: warning: Member variable 'result_parse_line::address' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:472:3: warning: Member variable 'result_parse_line::align' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:472:3: warning: Member variable 'result_parse_line::line' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line() {}
  ^
src/asm_struct_enum.h:691:3: warning: Member variable '_arguments::intval' is not initialized in the constructor. [uninitMemberVar]
  _arguments() { vartype = __unknown__; }
  ^
src/asm_struct_enum.h:691:3: warning: Member variable '_arguments::floatval' is not initialized in the constructor. [uninitMemberVar]
  _arguments() { vartype = __unknown__; }
  ^
src/asm_struct_enum.h:692:3: warning: Member variable '_arguments::floatval' is not initialized in the constructor. [uninitMemberVar]
  _arguments(int val) {
  ^
src/asm_struct_enum.h:696:3: warning: Member variable '_arguments::intval' is not initialized in the constructor. [uninitMemberVar]
  _arguments(float val) {
  ^
src/tokenizer.h:803:3: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
  Token() {
  ^
src/tokenizer.h:811:3: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
  Token(tokenType h) {
  ^
src/tokenizer.h:818:3: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
  Token(tokenType _type, int __vartype, int _line) {
  ^
src/tokenizer.h:825:3: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
  Token(tokenType _type, int __vartype) {
  ^
src/tokenizer.h:874:3: warning: Member variable 'Tokens::_script' is not initialized in the constructor. [uninitMemberVar]
  Tokens() {
  ^
src/execute.h:73:3: warning: Member variable '_executablesClass::nb_concurrent_programs_current' is not initialized in the constructor. [uninitMemberVar]
  _executablesClass() {
  ^
src/execute.h:237:3: warning: Member variable 'Executable::error' is not initialized in the constructor. [uninitMemberVar]
  Executable() {
  ^
src/execute.h:237:3: warning: Member variable 'Executable::df' is not initialized in the constructor. [uninitMemberVar]
  Executable() {
  ^
src/execute.h:245:3: warning: Member variable 'Executable::__run_handle_index' is not initialized in the constructor. [uninitMemberVar]
  Executable(executable _executable) {
  ^
src/execute.h:245:3: warning: Member variable 'Executable::error' is not initialized in the constructor. [uninitMemberVar]
  Executable(executable _executable) {
  ^
src/execute.h:245:3: warning: Member variable 'Executable::df' is not initialized in the constructor. [uninitMemberVar]
  Executable(executable _executable) {
  ^
src/asm_struct_enum.h:17:3: warning:inconclusive: Member variable 'Stack < int >::_default' is not initialized in the constructor. [uninitMemberVar]
  Stack() {}
  ^
src/asm_struct_enum.h:17:3: warning:inconclusive: Member variable 'Stack < bool >::_default' is not initialized in the constructor. [uninitMemberVar]
  Stack() {}
  ^
src/asm_struct_enum.h:17:3: warning:inconclusive: Member variable 'Stack < varTypeEnum >::_default' is not initialized in the constructor. [uninitMemberVar]
  Stack() {}
  ^
src/asm_struct_enum.h:18:18: performance: Variable '_default' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
  Stack(T def) { _default = def; }
                 ^
src/asm_struct_enum.h:181:10: style:inconclusive: Technically the member function 'Text::current' can be const. [functionConst]
  string current() { return string(*_it); }
         ^
src/asm_struct_enum.h:200:10: style:inconclusive: Technically the member function 'Text::textAt' can be const. [functionConst]
  string textAt(int pos) {
         ^
src/asm_struct_enum.h:315:7: style:inconclusive: Technically the member function 'Text::size' can be const. [functionConst]
  int size() { return _texts.size(); }
      ^
src/asm_struct_enum.h:350:7: style:inconclusive: Technically the member function 'Text::get' can be const. [functionConst]
  int get() { return position - 1; }
      ^
src/asm_struct_enum.h:716:7: style:inconclusive: Technically the member function 'Arguments::size' can be const. [functionConst]
  int size() { return _args.size(); }
      ^
src/tokenizer.h:728:8: style:inconclusive: Technically the member function 'Script::currentChar' can be const. [functionConst]
  char currentChar() {
       ^
src/tokenizer.h:833:13: style:inconclusive: Technically the member function 'Token::getType' can be const. [functionConst]
  tokenType getType() { return (tokenType)type; }
            ^
src/tokenizer.h:889:7: style:inconclusive: Technically the member function 'Tokens::size' can be const. [functionConst]
  int size() { return _tokens.size(); }
      ^
src/NodeToken.h:701:12: style:inconclusive: Technically the member function 'NodeToken::getNodeTokenType' can be const. [functionConst]
  nodeType getNodeTokenType() { return (nodeType)_nodetype; }
           ^
src/NodeToken.h:702:7: style:inconclusive: Technically the member function 'NodeToken::children_size' can be const. [functionConst]
  int children_size() {
      ^
src/NodeToken.h:984:8: performance:inconclusive: Technically the member function 'Context::addFunction' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  void addFunction(NodeToken *nd) {
       ^
src/NodeToken.h:1022:8: performance:inconclusive: Technically the member function 'Context::findCandidate' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  bool findCandidate(char *str) {
       ^
src/NodeToken.h:1047:8: performance:inconclusive: Technically the member function 'Context::findFunction' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  void findFunction(Token *t) {
       ^
src/execute.h:149:7: performance:inconclusive: Technically the member function '_executablesClass::getFirstHandle' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  int getFirstHandle() {
      ^
src/execute.h:459:8: style:inconclusive: Technically the member function 'Executable::isExeExists' can be const. [functionConst]
  bool isExeExists() { return exeExist; }
       ^
src/execute.h:570:8: style:inconclusive: Technically the member function 'Executable::isRunning' can be const. [functionConst]
  bool isRunning() { return _isRunning; }
       ^
src/ESPLiveScript.h:94:7: performance:inconclusive: Technically the member function 'Parser::size' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  int size() { return _tks->size(); }
      ^
src/ESPLiveScript.h:100:8: performance:inconclusive: Technically the member function 'Parser::Match' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  bool Match(tokenType tt) { return _tks->Match(tt); }
       ^
src/ESPLiveScript.h:101:8: performance:inconclusive: Technically the member function 'Parser::Match' can be static (but you may consider moving to unnamed namespace). [functionStatic]
  bool Match(tokenType tt, int index) { return _tks->Match(tt, index); }
       ^
src/asm_struct_enum.h:692:3: style: Class '_arguments' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  _arguments(int val) {
  ^
src/asm_struct_enum.h:696:3: style: Class '_arguments' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  _arguments(float val) {
  ^
src/tokenizer.h:811:3: style: Class 'Token' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Token(tokenType h) {
  ^
src/NodeToken.h:437:3: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  NodeToken(nodeType tt) {
  ^
src/NodeToken.h:448:3: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  NodeToken(Token *t) {
  ^
src/NodeToken.h:524:3: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  NodeToken(NodeToken *nd) {
  ^
src/execute.h:245:3: style: Class 'Executable' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Executable(executable _executable) {
  ^
src/asm_struct_enum.h:18:3: style: Class 'Stack < int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Stack(T def) { _default = def; }
  ^
src/asm_struct_enum.h:18:3: style: Class 'Stack < bool >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Stack(T def) { _default = def; }
  ^
src/asm_struct_enum.h:18:3: style: Class 'Stack < string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Stack(T def) { _default = def; }
  ^
src/asm_struct_enum.h:18:3: style: Class 'Stack < NodeToken >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Stack(T def) { _default = def; }
  ^
src/asm_struct_enum.h:18:3: style: Class 'Stack < varTypeEnum >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
  Stack(T def) { _default = def; }
  ^
src/NodeToken.h:3188:11: style: The if condition is the same as the previous if condition [duplicateCondition]
      if (regular) {
          ^
src/NodeToken.h:3156:11: note: First condition
      if (regular) {
          ^
src/NodeToken.h:3188:11: note: Second condition
      if (regular) {
          ^
src/NodeToken.h:3303:11: style: The if condition is the same as the previous if condition [duplicateCondition]
      if (regular)
          ^
src/NodeToken.h:3271:11: note: First condition
      if (regular) {
          ^
src/NodeToken.h:3303:11: note: Second condition
      if (regular)
          ^
src/asm_struct_enum.h:255:16: style: Condition '_pos>-1' is always false [knownConditionTrueFalse]
      if (_pos > -1 && _texts[_pos] != NULL) {
               ^
src/asm_struct_enum.h:254:15: note: Assignment '_pos=-1', assigned value is -1
      _pos = -1;
              ^
src/asm_struct_enum.h:255:16: note: Condition '_pos>-1' is always false
      if (_pos > -1 && _texts[_pos] != NULL) {
               ^
src/NodeToken.h:3345:9: style: Condition 't==NULL' is always false [knownConditionTrueFalse]
  if (t == NULL) {
        ^
src/NodeToken.h:3330:10: note: Assuming that condition 'nd==NULL' is not redundant
  if (nd == NULL) {
         ^
src/NodeToken.h:3344:18: note: Assignment 't=nd', assigned value is 0
  NodeToken *t = nd; // cntx.findFunction(nd->_token);
                 ^
src/NodeToken.h:3345:9: note: Condition 't==NULL' is always false
  if (t == NULL) {
        ^
src/execute.h:350:14: style: Condition '!toResetSync' is always false [knownConditionTrueFalse]
      while (!toResetSync) {
             ^
src/execute.h:349:21: note: Assignment 'toResetSync=true', assigned value is 1
      toResetSync = true;
                    ^
src/execute.h:350:14: note: Condition '!toResetSync' is always false
      while (!toResetSync) {
             ^
src/NodeToken.h:4231:13: warning: %lu in format string (no. 1) requires 'unsigned long *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
            sscanf(ndt->getTokenText(), "%lu", &__num);
            ^
src/execute.h:452:7: warning: %ld in format string (no. 1) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      printf("Free memory after:%ld freed:%ld\r\n", mema, mema - memb);
      ^
src/execute.h:452:7: warning: %ld in format string (no. 2) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
      printf("Free memory after:%ld freed:%ld\r\n", mema, mema - memb);
      ^
src/asm_external.h:60:35: information: --check-library: Function bindFunction() should have <noreturn> configuration [checkLibraryNoReturn]
  bindFunction(out, name, in, ptr);
                                  ^
src/asm_external.h:73:35: information: --check-library: Function bindVariable() should have <noreturn> configuration [checkLibraryNoReturn]
  bindVariable(out, name, in, ptr);
                                  ^
src/asm_struct_enum.h:510:5: information: --check-library: Function push_back() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return parsed_lines.back();
    ^
src/tokenizer.h:894:51: information: --check-library: Function tokenizer() should have <noreturn> configuration [checkLibraryNoReturn]
    tokenizer(script, true, increae_line, nbToken);
                                                  ^
src/tokenizer.h:903:53: information: --check-library: Function tokenizer() should have <noreturn> configuration [checkLibraryNoReturn]
    tokenizer(script, update, increae_line, nbToken);
                                                    ^
src/NodeToken.h:26:51: information: --check-library: Function ESP_LOGD() should have <noreturn> configuration [checkLibraryNoReturn]
  ESP_LOGD("ESPLiveScript", "%s\r\n", str.c_str());
                                                  ^
src/NodeToken.h:34:59: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
void pushToConsole(string str) { pushToConsole(str, false); }
                                                          ^
src/NodeToken.h:141:67: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
                              (__endtime - __starttime) / 240000));
                                                                  ^
src/NodeToken.h:143:37: information: --check-library: Function displayStat() should have <noreturn> configuration [checkLibraryNoReturn]
void displayStat() { displayStat(""); }
                                    ^
src/NodeToken.h:1794:60: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
    translateType(globalType.get(), r, register_numr.get());
                                                           ^
src/NodeToken.h:2280:74: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
        translateType(globalType.get(), v->_varType, register_numl.get());
                                                                         ^
src/NodeToken.h:2638:41: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
                    register_numl.get());
                                        ^
src/NodeToken.h:3770:46: information: --check-library: Function _visitCallFunctionTemplate() should have <noreturn> configuration [checkLibraryNoReturn]
    _visitCallFunctionTemplate(nd, 10, false);
                                             ^
src/NodeToken.h:3978:43: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
                      register_numl.get());
                                          ^
src/execute_asm.h:32:37: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(bin->binary_data);
                                    ^
src/execute_asm.h:34:39: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(bin->function_data);
                                      ^
src/execute_asm.h:234:5: information: --check-library: Function decodeBinaryHeader() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return exe;
    ^
src/execute_asm.h:241:5: information: --check-library: Function decodeBinaryHeader() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return exe;
    ^
src/execute_asm.h:375:9: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
      :);
        ^
src/execute_asm.h:523:46: information: --check-library: Function heap_caps_aligned_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_aligned_free(ex->start_program);
                                             ^
src/execute_asm.h:530:29: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(ex->data);
                            ^
src/execute_asm.h:554:22: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
                true);
                     ^
src/execute_asm.h:797:44: information: --check-library: Function addExternalFunction() should have <noreturn> configuration [checkLibraryNoReturn]
                        (void *)&showError);
                                           ^
src/execute.h:66:16: information: --check-library: Function vTaskDelay() should have <noreturn> configuration [checkLibraryNoReturn]
  vTaskDelay(1);
               ^
src/execute.h:130:68: information: --check-library: Function xEventGroupSync() should have <noreturn> configuration [checkLibraryNoReturn]
    xEventGroupSync(xCreatedEventGroup2, MASK, MASK, portMAX_DELAY);
                                                                   ^
src/execute.h:165:19: information: --check-library: Function _prekill() should have <noreturn> configuration [checkLibraryNoReturn]
        _prekill();
                  ^
src/execute.h:171:20: information: --check-library: Function _postkill() should have <noreturn> configuration [checkLibraryNoReturn]
        _postkill();
                   ^
src/execute.h:215:54: information: --check-library: Function xEventGroupClearBits() should have <noreturn> configuration [checkLibraryNoReturn]
      xEventGroupClearBits(xCreatedEventGroup2, MASK);
                                                     ^
src/execute.h:218:70: information: --check-library: Function xEventGroupSync() should have <noreturn> configuration [checkLibraryNoReturn]
    xEventGroupSync(xCreatedEventGroup2, 1 << h, MASK, portMAX_DELAY);
                                                                     ^
src/execute.h:295:35: information: --check-library: Function freeExecutable() should have <noreturn> configuration [checkLibraryNoReturn]
      freeExecutable(&_executecmd);
                                  ^
src/execute.h:315:76: information: --check-library: Function vTaskSuspend() should have <noreturn> configuration [checkLibraryNoReturn]
        vTaskSuspend(*runningPrograms.getHandleByIndex(__run_handle_index));
                                                                           ^
src/execute.h:323:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole("Program Halted.", true);
                                            ^
src/execute.h:422:57: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        pushToConsole("too many programs at once", true);
                                                        ^
src/execute.h:434:65: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole("Execution on going CTRL + k to stop", true);
                                                                ^
src/execute.h:436:49: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole("Nothing to execute.", true);
                                                ^
src/execute.h:468:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(res.error_message, true);
                                            ^
src/execute.h:481:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(res.error_message, true);
                                            ^
src/execute.h:496:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(res.error_message, true);
                                            ^
src/execute.h:608:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(res.error_message, true);
                                            ^
src/execute.h:617:45: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(res.error_message, true);
                                            ^
src/execute.h:625:20: information: --check-library: Function vTaskDelete() should have <noreturn> configuration [checkLibraryNoReturn]
  vTaskDelete(NULL);
                   ^
src/execute.h:661:65: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole("please add a name to the executable", true);
                                                                ^
src/ESPLiveScript.h:256:69: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        pushToConsole(_executecmd.error.error_message.c_str(), true);
                                                                    ^
src/asm_struct_enum.h:62:18: information: --check-library: Function push() should have <noreturn> configuration [checkLibraryNoReturn]
    push(sav + 1);
                 ^
src/asm_struct_enum.h:70:18: information: --check-library: Function push() should have <noreturn> configuration [checkLibraryNoReturn]
    push(sav - 1);
                 ^
src/NodeToken.h:1406:10: warning: Either the condition 'p!=NULL' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]
  while (p->_nodetype != forNode and p->_nodetype != whileNode) {
         ^
src/NodeToken.h:1411:9: note: Assuming that condition 'p!=NULL' is not redundant
  if (p != NULL) {
        ^
src/NodeToken.h:1406:10: note: Null pointer dereference
  while (p->_nodetype != forNode and p->_nodetype != whileNode) {
         ^
src/NodeToken.h:3326:24: warning: Either the condition 'nd==NULL' is redundant or there is possible null pointer dereference: nd. [nullPointerRedundantCheck]
  int staack_offset = (nd->getChildAtPos(0)->children_size() - 7) * 4;
                       ^
src/NodeToken.h:3330:10: note: Assuming that condition 'nd==NULL' is not redundant
  if (nd == NULL) {
         ^
src/NodeToken.h:3326:24: note: Null pointer dereference
  int staack_offset = (nd->getChildAtPos(0)->children_size() - 7) * 4;
                       ^
src/NodeToken.h:3781:7: warning: Either the condition 'v==NULL' is redundant or there is possible null pointer dereference: v. [nullPointerRedundantCheck]
  if (v->size > 1) {
      ^
src/NodeToken.h:3776:9: note: Assuming that condition 'v==NULL' is not redundant
  if (v == NULL) {
        ^
src/NodeToken.h:3781:7: note: Null pointer dereference
  if (v->size > 1) {
      ^
src/asm_struct_enum.h:507:9: style: C-style pointer casting [cstyleCast]
        (result_parse_line *)malloc(sizeof(result_parse_line));
        ^
src/asm_struct_enum.h:527:9: style: C-style pointer casting [cstyleCast]
        (result_parse_line *)malloc(sizeof(result_parse_line));
        ^
src/execute.h:592:23: style: C-style pointer casting [cstyleCast]
  Executable *exec = ((Executable *)pvParameters);
                      ^
src/NodeToken.h:1539:37: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
      uint32_t __num = (uint32_t)(*((uint32_t *)&__f));
                                    ^
src/NodeToken.h:4228:34: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
            __num = (uint32_t)(*((uint32_t *)&__f));
                                 ^
src/asm_struct_enum.h:254:12: style: Redundant initialization for '_pos'. The initialized value is overwritten before it is read. [redundantInitialization]
      _pos = -1;
           ^
src/asm_struct_enum.h:253:16: note: _pos is initialized
      int _pos = findText((char *)str.c_str());
               ^
src/asm_struct_enum.h:254:12: note: _pos is overwritten
      _pos = -1;
           ^
src/execute.h:479:9: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
        ^
src/execute.h:476:30: note: res is initialized
    error_message_struct res =
                             ^
src/execute.h:479:9: note: res is overwritten
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
        ^
src/execute.h:494:9: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args, json);
        ^
src/execute.h:491:30: note: res is initialized
    error_message_struct res =
                             ^
src/execute.h:494:9: note: res is overwritten
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args, json);
        ^
src/execute.h:511:9: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
        ^
src/execute.h:508:30: note: res is initialized
    error_message_struct res =
                             ^
src/execute.h:511:9: note: res is overwritten
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
        ^
src/execute.h:605:9: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
    res = executeBinary(_fg->args[0], exec->df.exe, exec->__run_handle_index,
        ^
src/execute.h:601:30: note: res is initialized
    error_message_struct res = executeBinary("@__footer", exec->df.exe,
                             ^
src/execute.h:605:9: note: res is overwritten
    res = executeBinary(_fg->args[0], exec->df.exe, exec->__run_handle_index,
        ^
src/execute.h:614:9: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
    res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec,
        ^
src/execute.h:612:30: note: res is initialized
    error_message_struct res = executeBinary("@__footer", exec->df.exe,
                             ^
src/execute.h:614:9: note: res is overwritten
    res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec,
        ^
src/ESPLiveScript.h:107:18: style: Variable 'point_regnum' is reassigned a value before the old one has been used. [redundantAssignment]
    point_regnum = 4;
                 ^
src/ESPLiveScript.h:106:18: note: point_regnum is assigned
    point_regnum = 4;
                 ^
src/ESPLiveScript.h:107:18: note: point_regnum is overwritten
    point_regnum = 4;
                 ^
src/NodeToken.h:3335:5: style:inconclusive: Found duplicate branches for 'if' and 'else'. [duplicateBranch]
    if (isExtCall)
    ^
src/NodeToken.h:3337:5: note: Found duplicate branches for 'if' and 'else'.
    else
    ^
src/NodeToken.h:3335:5: note: Found duplicate branches for 'if' and 'else'.
    if (isExtCall)
    ^
src/NodeToken.h:4867:7: style:inconclusive: Found duplicate branches for 'if' and 'else'. [duplicateBranch]
      if (strlen(nd->getChildAtPos(i)->getTokenText()) > 0)
      ^
src/NodeToken.h:4871:7: note: Found duplicate branches for 'if' and 'else'.
      else
      ^
src/NodeToken.h:4867:7: note: Found duplicate branches for 'if' and 'else'.
      if (strlen(nd->getChildAtPos(i)->getTokenText()) > 0)
      ^
src/NodeToken.h:1384:5: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
    break;
    ^
src/NodeToken.h:1492:5: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
    break;
    ^
src/NodeToken.h:3715:15: style: The scope of the variable 'sav' can be reduced. [variableScope]
          int sav;
              ^
src/NodeToken.h:4068:7: style: The scope of the variable 'sav' can be reduced. [variableScope]
  int sav = 9;
      ^
src/NodeToken.h:4222:15: style: The scope of the variable 'c' can be reduced. [variableScope]
      uint8_t c;
              ^
src/NodeToken.h:5119:17: style: The scope of the variable 'ind' can be reduced. [variableScope]
            int ind = -1;
                ^
src/asm_parser.h:88:9: style: The scope of the variable 'add_size' can be reduced. [variableScope]
    int add_size = 0;
        ^
src/asm_parser.h:403:12: style: The scope of the variable 'values' can be reduced. [variableScope]
  uint32_t values[4];
           ^
src/execute_asm.h:290:8: style: The scope of the variable 'ver' can be reduced. [variableScope]
  char ver[19];
       ^
src/ESPLiveScript.h:2769:11: style: The scope of the variable 'j' can be reduced. [variableScope]
      int j = 0;
          ^
src/execute.h:631:34: style:inconclusive: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'. [funcArgNamesDifferent]
void _executablesClass::kill(int handle_number) {
                                 ^
src/execute.h:103:17: note: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'.
  void kill(int handle);
                ^
src/execute.h:631:34: note: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'.
void _executablesClass::kill(int handle_number) {
                                 ^
src/tokenizer.h:1735:12: style: Local variable 'c2' shadows outer variable [shadowVariable]
      char c2 = script->nextChar();
           ^
src/tokenizer.h:1157:8: note: Shadowed declaration
  char c2;
       ^
src/tokenizer.h:1735:12: note: Shadow variable
      char c2 = script->nextChar();
           ^
src/tokenizer.h:1893:16: style: Local variable 'c2' shadows outer variable [shadowVariable]
          char c2 = script->nextChar();
               ^
src/tokenizer.h:1157:8: note: Shadowed declaration
  char c2;
       ^
src/tokenizer.h:1893:16: note: Shadow variable
          char c2 = script->nextChar();
               ^
src/NodeToken.h:985:16: style: Local variable '__tmpToken' shadows outer variable [shadowVariable]
    NodeToken *__tmpToken = new NodeToken();
               ^
src/NodeToken.h:414:12: note: Shadowed declaration
NodeToken *__tmpToken;
           ^
src/NodeToken.h:985:16: note: Shadow variable
    NodeToken *__tmpToken = new NodeToken();
               ^
src/NodeToken.h:2332:9: style: Local variable 'start' shadows outer variable [shadowVariable]
    int start = nd->stack_pos;
        ^
src/NodeToken.h:2321:7: note: Shadowed declaration
  int start = nd->stack_pos;
      ^
src/NodeToken.h:2332:9: note: Shadow variable
    int start = nd->stack_pos;
        ^
src/NodeToken.h:4081:13: style: Local variable 'start' shadows outer variable [shadowVariable]
        int start = nd->getChildAtPos(i)->stack_pos;
            ^
src/NodeToken.h:4078:11: note: Shadowed declaration
      int start = nd->getChildAtPos(i)->stack_pos;
          ^
src/NodeToken.h:4081:13: note: Shadow variable
        int start = nd->getChildAtPos(i)->stack_pos;
            ^
src/NodeToken.h:5007:24: style: Local variable 'd2' shadows outer variable [shadowVariable]
        vector<string> d2 = split(tmp, " ");
                       ^
src/NodeToken.h:4952:18: note: Shadowed declaration
  vector<string> d2;
                 ^
src/NodeToken.h:5007:24: note: Shadow variable
        vector<string> d2 = split(tmp, " ");
                       ^
src/NodeToken.h:5011:26: style: Local variable 'd' shadows outer variable [shadowVariable]
          vector<string> d = split(before, " ");
                         ^
src/NodeToken.h:4951:18: note: Shadowed declaration
  vector<string> d;
                 ^
src/NodeToken.h:5011:26: note: Shadow variable
          vector<string> d = split(before, " ");
                         ^
src/NodeToken.h:5120:18: style: Local variable 'found' shadows outer variable [shadowVariable]
            bool found = false;
                 ^
src/NodeToken.h:62:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5120:18: note: Shadow variable
            bool found = false;
                 ^
src/NodeToken.h:5162:18: style: Local variable 'found' shadows outer variable [shadowVariable]
            bool found = false;
                 ^
src/NodeToken.h:62:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5162:18: note: Shadow variable
            bool found = false;
                 ^
src/NodeToken.h:5249:18: style: Local variable 'found' shadows outer variable [shadowVariable]
            bool found = false;
                 ^
src/NodeToken.h:62:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5249:18: note: Shadow variable
            bool found = false;
                 ^
src/NodeToken.h:5304:18: style: Local variable 'found' shadows outer variable [shadowVariable]
            bool found = false;
                 ^
src/NodeToken.h:62:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5304:18: note: Shadow variable
            bool found = false;
                 ^
src/NodeToken.h:5354:18: style: Local variable 'found' shadows outer variable [shadowVariable]
            bool found = false;
                 ^
src/NodeToken.h:62:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5354:18: note: Shadow variable
            bool found = false;
                 ^
src/asm_parser.h:1163:22: style: Local variable '__v' shadows outer variable [shadowVariable]
      vector<string> __v = split(trim(str), " ");
                     ^
src/tokenizer.h:63:9: note: Shadowed declaration
varType __v;
        ^
src/asm_parser.h:1163:22: note: Shadow variable
      vector<string> __v = split(trim(str), " ");
                     ^
src/execute_asm.h:74:16: style: Local variable 'content' shadows outer variable [shadowVariable]
      uint32_t content = bincode + address;
               ^
src/NodeToken.h:360:6: note: Shadowed declaration
Text content;
     ^
src/execute_asm.h:74:16: note: Shadow variable
      uint32_t content = bincode + address;
               ^
src/execute_asm.h:88:18: style: Local variable 'content' shadows outer variable [shadowVariable]
        uint32_t content;
                 ^
src/NodeToken.h:360:6: note: Shadowed declaration
Text content;
     ^
src/execute_asm.h:88:18: note: Shadow variable
        uint32_t content;
                 ^
src/execute_asm.h:126:18: style: Local variable 'content' shadows outer variable [shadowVariable]
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/NodeToken.h:360:6: note: Shadowed declaration
Text content;
     ^
src/execute_asm.h:126:18: note: Shadow variable
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/execute_asm.h:477:18: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (int i = 1; i < args.size(); i++) {
                 ^
src/execute_asm.h:448:12: note: Shadowed declaration
  for (int i = 0; i < ex.functions.size(); i++) {
           ^
src/execute_asm.h:477:18: note: Shadow variable
        for (int i = 1; i < args.size(); i++) {
                 ^
src/ESPLiveScript.h:336:20: style: Local variable 'i' shadows outer variable [shadowVariable]
          for (int i = 0; i < __DEPTH; i++) {
                   ^
src/ESPLiveScript.h:321:16: note: Shadowed declaration
      for (int i = 0; i < external_links.size(); i++) {
               ^
src/ESPLiveScript.h:336:20: note: Shadow variable
          for (int i = 0; i < __DEPTH; i++) {
                   ^
src/ESPLiveScript.h:427:21: style: Local variable 'nd' shadows outer variable [shadowVariable]
          NodeToken nd = NodeToken(changeTypeNode);
                    ^
src/ESPLiveScript.h:401:17: note: Shadowed declaration
      NodeToken nd = NodeToken(changeTypeNode);
                ^
src/ESPLiveScript.h:427:21: note: Shadow variable
          NodeToken nd = NodeToken(changeTypeNode);
                    ^
src/ESPLiveScript.h:672:14: style: Local variable '_signature' shadows outer variable [shadowVariable]
      string _signature = sigs.back() + "*";
             ^
src/ESPLiveScript.h:667:12: note: Shadowed declaration
    string _signature = sigs.back() + current_node->getVarType()->varName;
           ^
src/ESPLiveScript.h:672:14: note: Shadow variable
      string _signature = sigs.back() + "*";
             ^
src/ESPLiveScript.h:686:17: style: Local variable 'nd' shadows outer variable [shadowVariable]
      NodeToken nd = NodeToken(changeTypeNode);
                ^
src/ESPLiveScript.h:655:15: note: Shadowed declaration
    NodeToken nd = NodeToken(changeTypeNode);
              ^
src/ESPLiveScript.h:686:17: note: Shadow variable
      NodeToken nd = NodeToken(changeTypeNode);
                ^
src/ESPLiveScript.h:697:14: style: Local variable '_signature' shadows outer variable [shadowVariable]
      string _signature =
             ^
src/ESPLiveScript.h:667:12: note: Shadowed declaration
    string _signature = sigs.back() + current_node->getVarType()->varName;
           ^
src/ESPLiveScript.h:697:14: note: Shadow variable
      string _signature =
             ^
src/ESPLiveScript.h:703:16: style: Local variable '_signature' shadows outer variable [shadowVariable]
        string _signature = sigs.back() + "*";
               ^
src/ESPLiveScript.h:697:14: note: Shadowed declaration
      string _signature =
             ^
src/ESPLiveScript.h:703:16: note: Shadow variable
        string _signature = sigs.back() + "*";
               ^
src/ESPLiveScript.h:1944:17: style: Local variable '_nd' shadows outer variable [shadowVariable]
      NodeToken _nd = nodeTokenList.pop();
                ^
src/ESPLiveScript.h:1899:15: note: Shadowed declaration
    NodeToken _nd = nodeTokenList.pop();
              ^
src/ESPLiveScript.h:1944:17: note: Shadow variable
      NodeToken _nd = nodeTokenList.pop();
                ^
src/ESPLiveScript.h:1946:17: style: Local variable '_t' shadows outer variable [shadowVariable]
      NodeToken _t = nodeTokenList.pop();
                ^
src/ESPLiveScript.h:1901:15: note: Shadowed declaration
    NodeToken _t = nodeTokenList.pop();
              ^
src/ESPLiveScript.h:1946:17: note: Shadow variable
      NodeToken _t = nodeTokenList.pop();
                ^
src/ESPLiveScript.h:2968:27: style: Local variable 'nd' shadows outer variable [shadowVariable]
                NodeToken nd = NodeToken(current(), defLocalVariableNode);
                          ^
src/ESPLiveScript.h:2940:25: note: Shadowed declaration
              NodeToken nd = NodeToken(current(), defLocalVariableNode);
                        ^
src/ESPLiveScript.h:2968:27: note: Shadow variable
                NodeToken nd = NodeToken(current(), defLocalVariableNode);
                          ^
src/ESPLiveScript.h:3096:27: style: Local variable 'nd' shadows outer variable [shadowVariable]
                NodeToken nd = nodeTokenList.pop();
                          ^
src/ESPLiveScript.h:3073:23: note: Shadowed declaration
            NodeToken nd = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:3096:27: note: Shadow variable
                NodeToken nd = nodeTokenList.pop();
                          ^
src/ESPLiveScript.h:3097:27: style: Local variable '_t' shadows outer variable [shadowVariable]
                NodeToken _t = nodeTokenList.pop();
                          ^
src/ESPLiveScript.h:3074:23: note: Shadowed declaration
            NodeToken _t = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:3097:27: note: Shadow variable
                NodeToken _t = nodeTokenList.pop();
                          ^
src/ESPLiveScript.h:3208:25: style: Local variable 'nd' shadows outer variable [shadowVariable]
              NodeToken nd = NodeToken(*current_node);
                        ^
src/ESPLiveScript.h:3073:23: note: Shadowed declaration
            NodeToken nd = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:3208:25: note: Shadow variable
              NodeToken nd = NodeToken(*current_node);
                        ^
src/ESPLiveScript.h:3242:25: style: Local variable 'nd' shadows outer variable [shadowVariable]
              NodeToken nd = NodeToken(*current_node);
                        ^
src/ESPLiveScript.h:3073:23: note: Shadowed declaration
            NodeToken nd = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:3242:25: note: Shadow variable
              NodeToken nd = NodeToken(*current_node);
                        ^
src/asm_external.h:22:38: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void bindFunction(string out, string name, string in, void *ptr) {
                                     ^
src/asm_external.h:22:51: performance: Function parameter 'in' should be passed by const reference. [passedByValue]
void bindFunction(string out, string name, string in, void *ptr) {
                                                  ^
src/asm_external.h:59:33: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalFunction(string name, string out, string in, void *ptr) {
                                ^
src/asm_external.h:59:46: performance: Function parameter 'out' should be passed by const reference. [passedByValue]
void addExternalFunction(string name, string out, string in, void *ptr) {
                                             ^
src/asm_external.h:59:58: performance: Function parameter 'in' should be passed by const reference. [passedByValue]
void addExternalFunction(string name, string out, string in, void *ptr) {
                                                         ^
src/asm_external.h:62:26: performance: Function parameter 'out' should be passed by const reference. [passedByValue]
void bindVariable(string out, string name, string in, void *ptr) {
                         ^
src/asm_external.h:62:38: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void bindVariable(string out, string name, string in, void *ptr) {
                                     ^
src/asm_external.h:62:51: performance: Function parameter 'in' should be passed by const reference. [passedByValue]
void bindVariable(string out, string name, string in, void *ptr) {
                                                  ^
src/asm_external.h:72:33: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out, string in, void *ptr) {
                                ^
src/asm_external.h:72:46: performance: Function parameter 'out' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out, string in, void *ptr) {
                                             ^
src/asm_external.h:72:58: performance: Function parameter 'in' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out, string in, void *ptr) {
                                                         ^
src/asm_external.h:76:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternal(string name, externalType type, void *ptr) {
                        ^
src/asm_struct_enum.h:133:33: performance: Function parameter 's' should be passed by const reference. [passedByValue]
  void addAfter(int pos, string s) {
                                ^
src/asm_struct_enum.h:144:34: performance: Function parameter 's' should be passed by const reference. [passedByValue]
  void addBefore(int pos, string s) {
                                 ^
src/tokenizer.h:518:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalDefine(string name, string content) {
                              ^
src/tokenizer.h:518:44: performance: Function parameter 'content' should be passed by const reference. [passedByValue]
void addExternalDefine(string name, string content) {
                                           ^
src/tokenizer.h:1018:25: performance: Function parameter 't' should be passed by const reference. [passedByValue]
void displaytoken(token t) {
                        ^
src/NodeToken.h:34:27: performance: Function parameter 'str' should be passed by const reference. [passedByValue]
void pushToConsole(string str) { pushToConsole(str, false); }
                          ^
src/NodeToken.h:537:20: performance: Function parameter '_target' should be passed by const reference. [passedByValue]
  NodeToken(string _target, nodeType tt) {
                   ^
src/NodeToken.h:542:47: performance: Function parameter '_target' should be passed by const reference. [passedByValue]
  NodeToken(NodeToken nd, nodeType tt, string _target) {
                                              ^
src/asm_parser.h:398:41: performance: Function parameter 'str' should be passed by const reference. [passedByValue]
result_parse_line parseOperandes(string str, int nboperande,
                                        ^
src/asm_parser.h:438:22: performance: Function parameter 's' should be passed by const reference. [passedByValue]
int findLabel(string s, parsedLines *asm_parsed) {
                     ^
src/execute_asm.h:439:64: performance: Function parameter 'json' should be passed by const reference. [passedByValue]
                                   Arguments arguments, string json) {
                                                               ^
src/execute_asm.h:510:43: performance: Function parameter 'function' should be passed by const reference. [passedByValue]
error_message_struct executeBinary(string function, executable ex,
                                          ^
src/execute_asm.h:510:64: performance: Function parameter 'ex' should be passed by const reference. [passedByValue]
error_message_struct executeBinary(string function, executable ex,
                                                               ^
src/execute_asm.h:512:46: performance: Function parameter 'arguments' should be passed by const reference. [passedByValue]
                                   Arguments arguments) {
                                             ^
src/execute.h:385:27: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
  int _run(vector<string> args, bool second_core, int core, Arguments arguments,
                          ^
src/execute.h:385:71: performance: Function parameter 'arguments' should be passed by const reference. [passedByValue]
  int _run(vector<string> args, bool second_core, int core, Arguments arguments,
                                                                      ^
src/execute.h:386:19: performance: Function parameter 'json' should be passed by const reference. [passedByValue]
           string json) {
                  ^
src/execute.h:461:27: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeOnly(string prog) {
                          ^
src/execute.h:472:23: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void execute(string prog) {
                      ^
src/execute.h:486:23: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void execute(string prog, string json) {
                      ^
src/execute.h:486:36: performance: Function parameter 'json' should be passed by const reference. [passedByValue]
  void execute(string prog, string json) {
                                   ^
src/execute.h:501:23: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void execute(string prog, Arguments arguments) {
                      ^
src/execute.h:517:29: performance: Function parameter 'function' should be passed by const reference. [passedByValue]
  bool functionExist(string function) {
                            ^
src/execute.h:531:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, int core, Arguments arguments, string json) {
                            ^
src/execute.h:531:73: performance: Function parameter 'json' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, int core, Arguments arguments, string json) {
                                                                        ^
src/execute.h:549:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, int core, Arguments arguments) {
                            ^
src/execute.h:549:55: performance: Function parameter 'arguments' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, int core, Arguments arguments) {
                                                      ^
src/execute.h:552:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, Arguments arguments) {
                            ^
src/execute.h:552:45: performance: Function parameter 'arguments' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, Arguments arguments) {
                                            ^
src/execute.h:555:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog) {
                            ^
src/execute.h:560:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, int core) {
                            ^
src/execute.h:564:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, string json) {
                            ^
src/execute.h:564:42: performance: Function parameter 'json' should be passed by const reference. [passedByValue]
  void executeAsTask(string prog, string json) {
                                         ^
src/execute.h:571:43: performance: Function parameter 'json' should be passed by const reference. [passedByValue]
  error_message_struct updateParam(string json) {
                                          ^
src/execute.h:664:37: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void addExe(Executable df, string name) {
                                    ^
src/execute.h:677:23: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void execute(string name) {
                      ^
src/execute.h:686:24: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeJ(string name, string json) {
                       ^
src/execute.h:695:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  bool functionExist(string name, string function) {
                            ^
src/execute.h:706:23: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void execute(string name, string function) {
                      ^
src/execute.h:716:23: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void execute(string name, string function, string json) {
                      ^
src/execute.h:726:23: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void execute(string name, Arguments arguments) {
                      ^
src/execute.h:736:23: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void execute(string name, string function, Arguments arguments) {
                      ^
src/execute.h:745:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name, Arguments arguments) {
                            ^
src/execute.h:754:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name) {
                            ^
src/execute.h:763:30: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTaskJ(string name, string json) {
                             ^
src/execute.h:772:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name, string function, Arguments arguments) {
                            ^
src/execute.h:782:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name, string function) {
                            ^
src/execute.h:791:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name, int core, Arguments args) {
                            ^
src/execute.h:800:29: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void executeAsTask(string name, int core) {
                            ^
src/execute.h:809:20: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void kill(string name) {
                   ^
src/execute.h:835:20: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  void free(string name) {
                   ^
src/execute.h:874:37: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
  exe_info getExecutableInfo(string name) {
                                    ^
src/asm_struct_enum.h:18:11: performance: Function parameter 'def' should be passed by const reference. [passedByValue]
  Stack(T def) { _default = def; }
          ^
src/asm_struct_enum.h:54:14: performance: Function parameter 'k' should be passed by const reference. [passedByValue]
  void set(T k) {
             ^
src/ESPLiveScript.h:161:7: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
      pushToConsole(Error.error_message.c_str(), true);
      ^
src/ESPLiveScript.h:230:7: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
      pushToConsole(bin.error.error_message.c_str(), true);
      ^
src/ESPLiveScript.h:256:9: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
        pushToConsole(_executecmd.error.error_message.c_str(), true);
        ^
src/NodeToken.h:1166:44: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
        if (findfloat(child) == __float__) {
                                           ^
src/NodeToken.h:1182:47: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
        if (findfloat(child) == __uint32_t__) {
                                              ^
src/asm_external.h:57:28: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_external.h:57:28: error: Uninitialized struct member: asmex.offset [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_external.h:70:28: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_external.h:70:28: error: Uninitialized struct member: asmex.offset [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_external.h:83:28: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_external.h:83:28: error: Uninitialized struct member: asmex.offset [uninitStructMember]
  external_links.push_back(asmex);
                           ^
src/asm_parser.h:156:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:164:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:156:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:164:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:184:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:192:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:184:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:192:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:212:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:220:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:212:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:220:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:240:23: error: Uninitialized struct member: error.line [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:250:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:240:23: error: Uninitialized struct member: error.pos [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:250:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:269:23: error: Uninitialized struct member: error.line [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:279:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:269:23: error: Uninitialized struct member: error.pos [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:279:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:295:19: error: Uninitialized struct member: error.line [uninitStructMember]
      res.error = error;
                  ^
src/asm_parser.h:301:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:295:19: error: Uninitialized struct member: error.pos [uninitStructMember]
      res.error = error;
                  ^
src/asm_parser.h:301:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:1104:15: error: Uninitialized struct member: err.line [uninitStructMember]
  asm_Error = err;
              ^
src/asm_parser.h:1104:15: error: Uninitialized struct member: err.pos [uninitStructMember]
  asm_Error = err;
              ^
src/execute.h:885:12: error: Uninitialized variable: inf [uninitvar]
    return inf;
           ^
src/execute.h:878:11: note: Assuming condition is false
    if (f != NULL) {
          ^
src/execute.h:885:12: note: Uninitialized variable: inf
    return inf;
           ^
src/execute.h:890:14: error: Uninitialized variable: inf [uninitvar]
      return inf;
             ^
src/NodeToken.h:607:15: style: Variable 'nd.parent' is assigned a value that is never used. [unreadVariable]
    nd.parent = this;
              ^
src/NodeToken.h:1026:11: style: Unused variable: tocmp [unusedVariable]
    char *tocmp;
          ^
src/NodeToken.h:1051:11: style: Unused variable: tocmp [unusedVariable]
    char *tocmp;
          ^
src/NodeToken.h:2495:11: style: Variable 'sav' is assigned a value that is never used. [unreadVariable]
  int sav = 9;
          ^
src/NodeToken.h:3329:15: style: Variable 'nbfloat' is assigned a value that is never used. [unreadVariable]
  int nbfloat = 0;
              ^
src/NodeToken.h:4024:16: style: Variable 't' is assigned a value that is never used. [unreadVariable]
  NodeToken *t = nd;
               ^
src/NodeToken.h:4221:13: style: Variable '__num' is assigned a value that is never used. [unreadVariable]
      __num = 0;
            ^
src/asm_parser.h:88:18: style: Variable 'add_size' is assigned a value that is never used. [unreadVariable]
    int add_size = 0;
                 ^
src/asm_parser.h:1459:24: style: Unused variable: error [unusedVariable]
  error_message_struct error;
                       ^
src/execute_asm.h:57:9: style: Unused variable: textptr2 [unusedVariable]
  char *textptr2;
        ^
src/execute.h:720:17: style: Unused variable: args [unusedVariable]
      Arguments args;
                ^
src/ESPLiveScript.h:2849:19: style: Variable 'memberpos' is assigned a value that is never used. [unreadVariable]
    int memberpos = 0;
                  ^
src/ESPLiveScript.h:2850:16: style: Variable '_start' is assigned a value that is never used. [unreadVariable]
    int _start = 0;
               ^
src/ESPLiveScript.h:2851:14: style: Variable '_pos' is assigned a value that is never used. [unreadVariable]
    int _pos = 0;
             ^
main.cpp:15:17: style: Variable 'exec' is assigned a value that is never used. [unreadVariable]
 Executable exec=_parser.parseScript(&script);
                ^
src/asm_external.h:88:35: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it < external_links.end(); it++) {
                                  ^
src/asm_struct_enum.h:169:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      _it--;
      ^
src/asm_struct_enum.h:244:5: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
    _it++;
    ^
src/asm_struct_enum.h:275:10: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
         it++) {
         ^
src/asm_struct_enum.h:347:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      _it--;
      ^
src/tokenizer.h:747:9: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        it--;
        ^
src/tokenizer.h:767:5: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
    it++;
    ^
src/tokenizer.h:777:10: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
         _it++) {
         ^
src/tokenizer.h:787:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      it++;
      ^
src/NodeToken.h:1426:39: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
         it != __nd->children->end(); it++) {
                                      ^
src/asm_parser.h:116:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != _asm_parsed.end(); it++) {
                                ^
src/asm_parser.h:131:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != _asm_parsed.end(); it++) {
                                ^
src/asm_parser.h:442:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:460:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:1359:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:1427:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:1467:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:1500:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      it2++;
      ^
src/asm_parser.h:1523:33: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
       it != asm_parsed->end(); it++) {
                                ^
src/asm_parser.h:1588:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      it2++;
      ^
src/execute.h:825:40: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
           it != _scExecutables.end(); it++) {
                                       ^
src/NodeToken.h:167:16: information: --check-library: Function displayStat() should have <noreturn> configuration [checkLibraryNoReturn]
  displayStat();
               ^
src/execute_asm.h:608:19: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
  uint8_t third = scale8(offset8, (256 / 3)); // max = 85
                  ^
src/execute_asm.h:636:31: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
          uint8_t twothirds = scale8(offset8, ((256 * 2) / 3)); // max=170
                              ^
src/execute_asm.h:650:31: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
          uint8_t twothirds = scale8(offset8, ((256 * 2) / 3)); // max=170
                              ^
src/execute_asm.h:682:29: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        uint8_t twothirds = scale8(offset8, ((256 * 2) / 3)); // max=170
                            ^
src/execute_asm.h:717:9: information: --check-library: There is no matching configuration for function scale8_video_LEAVING_R1_DIRTY() [checkLibraryFunction]
    g = scale8_video_LEAVING_R1_DIRTY(g, Gscale);
        ^
src/execute_asm.h:728:15: information: --check-library: There is no matching configuration for function scale8_video() [checkLibraryFunction]
      desat = scale8_video(desat, desat);
              ^
src/execute_asm.h:741:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        r = scale8(r, satscale) + 1;
            ^
src/execute_asm.h:743:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        g = scale8(g, satscale) + 1;
            ^
src/execute_asm.h:745:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        b = scale8(b, satscale) + 1;
            ^
src/execute_asm.h:757:11: information: --check-library: There is no matching configuration for function scale8_video_LEAVING_R1_DIRTY() [checkLibraryFunction]
    val = scale8_video_LEAVING_R1_DIRTY(val, val);
          ^
src/execute_asm.h:771:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        r = scale8(r, val) + 1;
            ^
src/execute_asm.h:773:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        g = scale8(g, val) + 1;
            ^
src/execute_asm.h:775:13: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
        b = scale8(b, val) + 1;
            ^
src/execute_asm.h:786:10: information: --check-library: There is no matching configuration for function CRGB() [checkLibraryFunction]
  return CRGB(r, g, b);
         ^
src/execute_asm.h:623:27: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
        FORCE_REFERENCE(b);
                          ^
src/execute_asm.h:631:29: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
          FORCE_REFERENCE(b);
                            ^
src/execute_asm.h:639:29: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
          FORCE_REFERENCE(b);
                            ^
src/execute_asm.h:654:29: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
          FORCE_REFERENCE(b);
                            ^
src/execute_asm.h:660:29: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
          FORCE_REFERENCE(b);
                            ^
src/execute_asm.h:799:67: information: --check-library: Function addExternalFunction() should have <noreturn> configuration [checkLibraryNoReturn]
    addExternalFunction("hsv", "CRGB", "int,int,int", (void *)hsv);
                                                                  ^
src/execute.h:256:19: information: --check-library: There is no matching configuration for function createExectutable() [checkLibraryFunction]
    _executecmd = createExectutable(bin);
                  ^
src/execute.h:295:7: information: --check-library: There is no matching configuration for function freeExecutable() [checkLibraryFunction]
      freeExecutable(&_executecmd);
      ^
src/execute.h:449:7: information: --check-library: There is no matching configuration for function freeExecutable() [checkLibraryFunction]
      freeExecutable(&_executecmd);
      ^
src/execute.h:466:9: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        executeBinary("@_" + prog, _executecmd, 9999, this, args);
        ^
src/execute.h:477:9: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        executeBinary("@__footer", _executecmd, 9999, this, d);
        ^
src/execute.h:479:11: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
          ^
src/execute.h:492:9: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        executeBinary("@__footer", _executecmd, 9999, this, d);
        ^
src/execute.h:494:11: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args, json);
          ^
src/execute.h:509:9: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        executeBinary("@__footer", _executecmd, 9999, this, d);
        ^
src/execute.h:511:11: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
          ^
src/execute.h:601:32: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    error_message_struct res = executeBinary("@__footer", exec->df.exe,
                               ^
src/execute.h:605:11: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    res = executeBinary(_fg->args[0], exec->df.exe, exec->__run_handle_index,
          ^
src/execute.h:612:32: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    error_message_struct res = executeBinary("@__footer", exec->df.exe,
                               ^
src/execute.h:614:11: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
    res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec,
          ^
src/ESPLiveScript.h:208:11: information: --check-library: There is no matching configuration for function createBinary() [checkLibraryFunction]
    bin = createBinary(&footer, &header, &content, __parser_debug);
          ^
src/ESPLiveScript.h:231:7: information: --check-library: There is no matching configuration for function freeBinary() [checkLibraryFunction]
      freeBinary(&bin);
      ^
src/ESPLiveScript.h:246:32: information: --check-library: There is no matching configuration for function createExectutable() [checkLibraryFunction]
      executable _executecmd = createExectutable(&bin);
                               ^
src/NodeToken.h:23:9: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
  LedOS.pushToConsole(str, force);
        ^
src/ESPLiveScript.h:3331:13: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
      LedOS.pushToConsole("Something Already running kill it first ...");
            ^
src/ESPLiveScript.h:3347:5: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
    _push(config.ENDLINE);
    ^
src/ESPLiveScript.h:3348:5: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
    _push(cons->prompt(cons).c_str());
    ^
src/ESPLiveScript.h:3348:17: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
    _push(cons->prompt(cons).c_str());
                ^
src/ESPLiveScript.h:3379:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole("Compiling ...", true);
          ^
src/ESPLiveScript.h:3386:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole("filename missing ...", true);
          ^
src/ESPLiveScript.h:3403:13: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
      LedOS.pushToConsole("Something Already running kill it first ...");
            ^
src/ESPLiveScript.h:3427:14: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
      Serial.printf("oioioioe");
             ^
src/ESPLiveScript.h:3438:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("***********START RUN *********");
              ^
src/ESPLiveScript.h:3443:11: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
          _push(config.ENDLINE);
          ^
src/ESPLiveScript.h:3444:11: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
          _push(cons->prompt(cons).c_str());
          ^
src/ESPLiveScript.h:3444:23: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
          _push(cons->prompt(cons).c_str());
                      ^
src/ESPLiveScript.h:3447:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("Start program", true);
              ^
src/ESPLiveScript.h:3450:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("Execution done.", true);
              ^
src/ESPLiveScript.h:3456:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole("filename missing ...", true);
          ^
src/ESPLiveScript.h:3461:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole("Something Already running kill it first ...");
          ^
src/ESPLiveScript.h:3468:9: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
  LedOS.pushToConsole("Compiling ...", true);
        ^
src/ESPLiveScript.h:3484:13: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
      LedOS.pushToConsole("***********START RUN *********");
            ^
src/ESPLiveScript.h:3488:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(config.ENDLINE);
        ^
src/ESPLiveScript.h:3489:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
        ^
src/ESPLiveScript.h:3489:21: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
                    ^
src/ESPLiveScript.h:3492:13: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
      LedOS.pushToConsole("Start program", true);
            ^
src/ESPLiveScript.h:3495:13: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
      LedOS.pushToConsole("Execution done.", true);
            ^
src/ESPLiveScript.h:3498:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole(SCExecutable.error.error_message, true);
          ^
src/ESPLiveScript.h:3512:5: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
    _push(config.ENDLINE);
    ^
src/ESPLiveScript.h:3513:5: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
    _push(cons->prompt(cons).c_str());
    ^
src/ESPLiveScript.h:3513:17: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
    _push(cons->prompt(cons).c_str());
                ^
src/ESPLiveScript.h:3523:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand(
          ^
src/ESPLiveScript.h:3526:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("comp", compile_c, "Compile  a program");
          ^
src/ESPLiveScript.h:3527:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("createbin", saveBin,
          ^
src/ESPLiveScript.h:3529:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("executebin", binload, "executebin");
          ^
src/ESPLiveScript.h:3530:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("displaybin", displaybin, "displaybin");
          ^
src/ESPLiveScript.h:3531:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("./", binload, "executebin");
          ^
src/ESPLiveScript.h:3532:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("list", listExec, "list the compiled programs");
          ^
src/ESPLiveScript.h:3533:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand(
          ^
src/ESPLiveScript.h:3536:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("run", run,
          ^
src/ESPLiveScript.h:3539:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand(
          ^
src/ESPLiveScript.h:3542:11: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
    LedOS.addKeywordCommand("parseasm", parseasm, "Parse assembly program");
          ^
src/ESPLiveScript.h:3543:11: information: --check-library: There is no matching configuration for function LedOS::addEscCommand() [checkLibraryFunction]
    LedOS.addEscCommand(18, parsec_cEsc,
          ^
src/ESPLiveScript.h:3545:11: information: --check-library: There is no matching configuration for function LedOS::addEscCommand() [checkLibraryFunction]
    LedOS.addEscCommand(11, kill_cEsc, "Stop a running program");
          ^
src/ESPLiveScript.h:3699:11: information: --check-library: There is no matching configuration for function LedOS::addHightLightinf() [checkLibraryFunction]
    LedOS.addHightLightinf("sc", formatLine, formatInit, formatLine);
          ^
src/ESPLiveScript.h:3289:59: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole("Nothing is currently running.", true);
                                                          ^
src/ESPLiveScript.h:3332:23: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
      kill(cons, args);
                      ^
src/ESPLiveScript.h:3348:38: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
    _push(cons->prompt(cons).c_str());
                                     ^
src/ESPLiveScript.h:3361:24: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
                  true);
                       ^
src/ESPLiveScript.h:3363:47: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    pushToConsole(_scExec.error.error_message);
                                              ^
src/ESPLiveScript.h:3384:21: information: --check-library: Function freeBinary() should have <noreturn> configuration [checkLibraryNoReturn]
    freeBinary(&bin);
                    ^
src/ESPLiveScript.h:3394:21: information: --check-library: Function freeBinary() should have <noreturn> configuration [checkLibraryNoReturn]
    freeBinary(&bin);
                    ^
src/ESPLiveScript.h:3405:20: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
      kill(cons, k);
                   ^
src/ESPLiveScript.h:3429:67: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
      pushToConsole(_executecmd.error.error_message.c_str(), true);
                                                                  ^
src/ESPLiveScript.h:3444:44: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
          _push(cons->prompt(cons).c_str());
                                           ^
src/ESPLiveScript.h:3463:18: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
    kill(cons, k);
                 ^
src/ESPLiveScript.h:3489:42: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
        _push(cons->prompt(cons).c_str());
                                         ^
src/ESPLiveScript.h:3513:38: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
    _push(cons->prompt(cons).c_str());
                                     ^
src/NodeToken.h:1405:14: style: Local variable 'p' shadows outer variable [shadowVariable]
  NodeToken *p = current_node;
             ^
src/ESPLiveScript.h:3281:8: note: Shadowed declaration
Parser p = Parser();
       ^
src/NodeToken.h:1405:14: note: Shadow variable
  NodeToken *p = current_node;
             ^
src/NodeToken.h:5020:28: style: Local variable 'p' shadows outer variable [shadowVariable]
            vector<string> p = split(d[1], ",");
                           ^
src/ESPLiveScript.h:3281:8: note: Shadowed declaration
Parser p = Parser();
       ^
src/NodeToken.h:5020:28: note: Shadow variable
            vector<string> p = split(d[1], ",");
                           ^
src/ESPLiveScript.h:3296:33: performance: Function parameter 'variables' should be passed by const reference. [passedByValue]
Arguments parseInputArgs(string variables) {
                                ^
src/ESPLiveScript.h:3351:45: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void parseasm(Console *cons, vector<string> args) {}
                                            ^
src/ESPLiveScript.h:3352:46: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void compile_c(Console *cons, vector<string> args) {
                                             ^
src/ESPLiveScript.h:3517:45: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void listExec(Console *cons, vector<string> args) { scriptRuntime.listExec(); }
                                            ^
src/ESPLiveScript.h:3415:7: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
      pushToConsole(bin.error.error_message.c_str(), true);
      ^
src/ESPLiveScript.h:3429:7: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
      pushToConsole(_executecmd.error.error_message.c_str(), true);
      ^
src/ESPLiveScript.h:296:10: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
      sc = sc + "\n" + s;
         ^
src/ESPLiveScript.h:308:10: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
      sc = sc + "\n" + s;
         ^
src/ESPLiveScript.h:3386:54: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    LedOS.pushToConsole("filename missing ...", true);
                                                     ^
src/ESPLiveScript.h:3456:54: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    LedOS.pushToConsole("filename missing ...", true);
                                                     ^
src/ESPLiveScript.h:3407:20: style: Variable 'othercore' is assigned a value that is never used. [unreadVariable]
    bool othercore = false;
                   ^
src/execute_asm.h:184:18: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      jso.json = string(textptr);
                 ^
src/execute_asm.h:389:34: information: --check-library: There is no matching configuration for function deserializeJson() [checkLibraryFunction]
    DeserializationError error = deserializeJson(doc, json);
                                 ^
src/execute_asm.h:393:14: information: --check-library: There is no matching configuration for function Serial::print() [checkLibraryFunction]
      Serial.print(F("deserializeJson() failed: "));
             ^
src/execute_asm.h:393:20: information: --check-library: There is no matching configuration for function F() [checkLibraryFunction]
      Serial.print(F("deserializeJson() failed: "));
                   ^
src/execute_asm.h:394:14: information: --check-library: There is no matching configuration for function Serial::println() [checkLibraryFunction]
      Serial.println(error.f_str());
             ^
src/execute_asm.h:188:15: style: Local variable 'type' shadows outer variable [shadowVariable]
      uint8_t type;
              ^
src/execute_asm.h:48:11: note: Shadowed declaration
  uint8_t type;
          ^
src/execute_asm.h:188:15: note: Shadow variable
      uint8_t type;
              ^
src/execute_asm.h:12:50: performance: Function parameter 'str' should be passed by const reference. [passedByValue]
JsonVariant getfromJson(JsonDocument obj, string str) {
                                                 ^
src/execute_asm.h:434:10: error: Uninitialized variable: res [uninitvar]
  return res;
         ^
src/execute_asm.h:386:12: note: Assuming condition is false
  if (json != "") {
           ^
src/execute_asm.h:434:10: note: Uninitialized variable: res
  return res;
         ^
src/asm_struct_enum.h:210:13: style: Condition '!isReused(0)' is always true [knownConditionTrueFalse]
        if (!isReused(0)) {
            ^
src/asm_struct_enum.h:97:5: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
    for (int i = _texts.size() - 1; i >= 0; i--) {
    ^
src/asm_struct_enum.h:327:5: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
    if (pos < 0 or pos >= _texts.size()) {
    ^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

