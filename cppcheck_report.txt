src/NodeToken.h:4071:29: error: Using object that points to local variable '__f' that is out of scope. [invalidLifetime]
                        c = __num & 0xff;
                            ^
src/NodeToken.h:4062:58: note: Address of variable taken here.
                        __num = (uint32_t)(*((uint32_t *)&__f));
                                                         ^
src/NodeToken.h:4060:31: note: Variable created here.
                        float __f = 0;
                              ^
src/NodeToken.h:4071:29: note: Using object that points to local variable '__f' that is out of scope.
                        c = __num & 0xff;
                            ^
src/NodeToken.h:4074:33: error: Using object that points to local variable '__f' that is out of scope. [invalidLifetime]
                        __num = __num / 256;
                                ^
src/NodeToken.h:4062:58: note: Address of variable taken here.
                        __num = (uint32_t)(*((uint32_t *)&__f));
                                                         ^
src/NodeToken.h:4060:31: note: Variable created here.
                        float __f = 0;
                              ^
src/NodeToken.h:4074:33: note: Using object that points to local variable '__f' that is out of scope.
                        __num = __num / 256;
                                ^
src/string_function.h:44:17: information: --check-library: There is no matching configuration for function std::string() [checkLibraryFunction]
    return std::string( buf.get(), buf.get() + size - 1 ); // We don't want the '\0' inside
                ^
src/asm_struct_enum.h:199:33: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
            _it = _texts.insert(next(_it), m);
                                ^
src/asm_struct_enum.h:206:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            return string(_texts.back());
                   ^
src/asm_struct_enum.h:212:16: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        return string(*_it);
               ^
src/asm_struct_enum.h:216:19: information: --check-library: There is no matching configuration for function findText() [checkLibraryFunction]
        int pos = findText(" ");
                  ^
src/asm_struct_enum.h:233:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            return string(_texts.front());
                   ^
src/asm_struct_enum.h:241:16: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        return string(_texts[pos]);
               ^
src/asm_struct_enum.h:271:27: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            if (s.compare(string(*_it)) == 0)
                          ^
src/tokenizer.h:764:17: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
            if (next(it) == script.end())
                ^
src/tokenizer.h:772:22: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
                it = next(it);
                     ^
src/NodeToken.h:26:5: information: --check-library: There is no matching configuration for function ESP_LOGD() [checkLibraryFunction]
    ESP_LOGD("ESPLiveScript","%s\r\n", str.c_str());
    ^
src/NodeToken.h:113:38: information: --check-library: There is no matching configuration for function uxTaskGetStackHighWaterMark() [checkLibraryFunction]
    UBaseType_t stackHighWaterMark = uxTaskGetStackHighWaterMark(loopTaskHandle);
                                     ^
src/NodeToken.h:128:1: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
displayStat("");
^
src/NodeToken.h:142:38: information: --check-library: There is no matching configuration for function uxTaskGetStackHighWaterMark() [checkLibraryFunction]
    UBaseType_t stackHighWaterMark = uxTaskGetStackHighWaterMark(loopTaskHandle);
                                     ^
src/NodeToken.h:734:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                if (string(getTargetText()).compare(0, 1, "@") == 0)
                    ^
src/NodeToken.h:738:25: information: --check-library: There is no matching configuration for function findMember() [checkLibraryFunction]
                int i = findMember(_vartype, string(getTargetText()));
                        ^
src/NodeToken.h:738:46: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                int i = findMember(_vartype, string(getTargetText()));
                                             ^
src/NodeToken.h:777:45: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                int cmp = getChildAtPos(2)->getChildAtPos(i)->findMaxArgumentSize();
                                            ^
src/NodeToken.h:1565:15: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        res = string(p->getTargetText());
              ^
src/NodeToken.h:1716:18: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        else if (string(nd->getTokenText()).find("x") != string::npos)
                 ^
src/NodeToken.h:2214:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string sd = string(nd->getTargetText());
                    ^
src/NodeToken.h:2583:89: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            variables = string_format("%s %d", variables.c_str(), nd->getChildAtPos(1)->getChildAtPos(i)->getVarType()->total_size);
                                                                                        ^
src/NodeToken.h:2758:30: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            content.addAfter(string(_div[i]));
                             ^
src/NodeToken.h:3005:23: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    nd->setTargetText(string(nd->parent->getTargetText()));
                      ^
src/NodeToken.h:3248:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            if (nd->getChildAtPos(0)->getChildAtPos(j)->findMaxArgumentSize() - 1 >= i)
                                      ^
src/NodeToken.h:3274:34: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        if (t->getChildAtPos(0)->getChildAtPos(i)->isPointer)
                                 ^
src/NodeToken.h:3277:35: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                                  ^
src/NodeToken.h:3293:45: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                if (func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType == __Args__)
                                            ^
src/NodeToken.h:3297:57: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                globalType.push(func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType);
                                                        ^
src/NodeToken.h:3298:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                                      ^
src/NodeToken.h:3305:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                                      ^
src/NodeToken.h:3308:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            if (nd->getChildAtPos(0)->getChildAtPos(i)->getVarType() != NULL and convert)
                                      ^
src/NodeToken.h:3309:71: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                translateType(globalType.get(), nd->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType, register_numl.get());
                                                                      ^
src/NodeToken.h:3315:52: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                _vartype = func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType;
                                                   ^
src/NodeToken.h:3318:53: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    _vartype = t->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType;
                                                    ^
src/NodeToken.h:3332:49: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                _vartype = t->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType;
                                                ^
src/NodeToken.h:3356:42: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                if (t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->_nodetype == numberNode)
                                         ^
src/NodeToken.h:3380:62: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    for (int k = 0; k < t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->getVarType()->size; k++)
                                                             ^
src/NodeToken.h:3387:46: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    if (t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->_nodetype == callFunctionNode)
                                             ^
src/NodeToken.h:3399:46: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    if (t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->_nodetype == extCallFunctionNode)
                                             ^
src/NodeToken.h:3411:51: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    else if (t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->_nodetype == localVariableNode)
                                                  ^
src/NodeToken.h:3415:138: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                            bufferText->addAfter(bufferText->sp.pop(), string_format("l32i a%d,a1,%d", regbase + i, t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->stack_pos));
                                                                                                                                         ^
src/NodeToken.h:3420:138: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                            bufferText->addAfter(bufferText->sp.pop(), string_format("l32i a%d,a1,%d", regbase + i, t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->stack_pos));
                                                                                                                                         ^
src/NodeToken.h:3423:51: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    else if (t->getChildAtPos(2)->getChildAtPos(i)->getChildAtPos(0)->_nodetype == globalVariableNode)
                                                  ^
src/NodeToken.h:3473:49: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    v = func->getChildAtPos(1)->getChildAtPos(i)->getVarType();
                                                ^
src/NodeToken.h:3475:47: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    v = nd->getChildAtPos(0)->getChildAtPos(i)->getVarType();
                                              ^
src/NodeToken.h:3532:41: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            if (func->getChildAtPos(1)->getChildAtPos(i)->isPointer)
                                        ^
src/NodeToken.h:3537:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                                      ^
src/NodeToken.h:3539:53: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                int start = func->getChildAtPos(1)->getChildAtPos(i)->stack_pos - _STACK_SIZE;
                                                    ^
src/NodeToken.h:3563:57: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                globalType.push(func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType);
                                                        ^
src/NodeToken.h:3566:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                                      ^
src/NodeToken.h:3569:53: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                int start = func->getChildAtPos(1)->getChildAtPos(i)->stack_pos - _STACK_SIZE + func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->total_size;
                                                    ^
src/NodeToken.h:3570:51: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                int tot = func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size - 1;
                                                  ^
src/NodeToken.h:3571:61: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                for (int j = 0; j < func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size; j++)
                                                            ^
src/NodeToken.h:3574:47: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    if (nd->getChildAtPos(0)->getChildAtPos(i)->getVarType() != NULL)
                                              ^
src/NodeToken.h:3576:79: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                        translateType(globalType.get(), nd->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType, register_numl.get());
                                                                              ^
src/NodeToken.h:3585:54: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    start -= func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->sizes[tot - j];
                                                     ^
src/NodeToken.h:3586:71: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    asmInstruction asmInstr = func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->store[tot - j];
                                                                      ^
src/NodeToken.h:3594:58: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                        if (j == func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size - 1)
                                                         ^
src/NodeToken.h:3606:58: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                        if (j == func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size - 1)
                                                         ^
src/NodeToken.h:3759:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                string sd = string(nd->getTargetText());
                            ^
src/NodeToken.h:4041:26: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            string str = string(nd->getChildAtPos(0)->getTokenText());
                         ^
src/NodeToken.h:4238:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string sd = string(nd->getTargetText());
                    ^
src/NodeToken.h:4416:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string sd = string(nd->getTargetText());
                    ^
src/NodeToken.h:4673:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string target = string(nd->getTokenText());
                    ^
src/NodeToken.h:4731:26: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            string tmp = string((*text->getChildAtPos(i)));
                         ^
src/NodeToken.h:4808:22: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string tmp = string((*text->getChildAtPos(i)));
                     ^
src/NodeToken.h:4859:26: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            string tmp = string((*text->getChildAtPos(i)));
                         ^
src/NodeToken.h:4904:26: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            string tmp = string((*text->getChildAtPos(i)));
                         ^
src/asm_parser.h:502:16: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      if (trim(string((*it)->getText())).compare(trim(s)) == 0)
               ^
src/asm_parser.h:544:19: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    if (findLabel(string(res.getText()), asm_parsed) != -1)
                  ^
src/asm_parser.h:1037:27: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    int index = findLabel(string(ps.getText()), asm_parsed);
                          ^
src/asm_parser.h:1063:27: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    int index = findLabel(string(ps.getText()), asm_parsed);
                          ^
src/asm_parser.h:1347:9: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
        displayStat("before mem");
        ^
src/asm_parser.h:1351:9: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
        displayStat("after mem");
        ^
src/asm_parser.h:1572:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLabel(string(parse_line->getText()), asm_parsed);
                            ^
src/asm_parser.h:1741:40: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      vector<string> args = split(trim(string((*it2)->getText())), " ");
                                       ^
src/asm_parser.h:1746:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLabel(string((*it)->getText()), asm_parsed);
                            ^
src/asm_parser.h:1752:30: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string stackstring = string((*it)->getText()).insert(2, "stack_");
                             ^
src/asm_parser.h:1779:9: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
        displayStat("before call parsem");
        ^
src/asm_parser.h:1822:18: information: --check-library: There is no matching configuration for function fs::FS::open() [checkLibraryFunction]
  File root = fs.open(name, FILE_WRITE);
                 ^
src/asm_parser.h:1823:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)"ESPLiveScript1.0.1", 19);
       ^
src/asm_parser.h:1824:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->tmp_instruction_size, 2);
       ^
src/asm_parser.h:1827:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->instruction_size, 2);
       ^
src/asm_parser.h:1830:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->data_size, 2);
       ^
src/asm_parser.h:1833:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->function_size, 2);
       ^
src/asm_parser.h:1836:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write(bin->binary_data, bin->tmp_instruction_size);
       ^
src/asm_parser.h:1837:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write(bin->function_data, bin->function_size);
       ^
src/execute_asm.h:9:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(bin->binary_data);
    ^
src/execute_asm.h:11:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(bin->function_data);
    ^
src/execute_asm.h:68:28: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLink(string(textptr).substr(6, 100), externalType::value);
                           ^
src/execute_asm.h:99:28: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLink(string(textptr).substr(2, 100), externalType::function);
                           ^
src/execute_asm.h:143:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      gc.name = string(textptr);
                ^
src/execute_asm.h:148:22: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      gc.variables = string(textptr);
                     ^
src/execute_asm.h:179:32: information: --check-library: There is no matching configuration for function heap_caps_malloc() [checkLibraryFunction]
  uint32_t *exec = (uint32_t *)heap_caps_malloc(bin->instruction_size, MALLOC_CAP_EXEC);
                               ^
src/execute_asm.h:278:18: information: --check-library: There is no matching configuration for function fs::FS::open() [checkLibraryFunction]
  File root = fs.open(name);
                 ^
src/execute_asm.h:281:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)ver, 19);
       ^
src/execute_asm.h:289:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->tmp_instruction_size, 2);
       ^
src/execute_asm.h:292:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->instruction_size, 2);
       ^
src/execute_asm.h:295:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->data_size, 2);
       ^
src/execute_asm.h:298:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->function_size, 2);
       ^
src/execute_asm.h:303:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read(tmp, bin->tmp_instruction_size);
       ^
src/execute_asm.h:306:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read(tmp2, bin->function_size);
       ^
src/execute_asm.h:413:5: information: --check-library: There is no matching configuration for function heap_caps_aligned_free() [checkLibraryFunction]
    heap_caps_aligned_free(ex->start_program);
    ^
src/execute_asm.h:421:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(ex->data);
    ^
src/execute.h:70:5: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
    vTaskDelay(1);
    ^
src/execute.h:124:17: information: --check-library: There is no matching configuration for function vTaskSuspend() [checkLibraryFunction]
                vTaskSuspend(__run_handles[i]);
                ^
src/execute.h:136:17: information: --check-library: There is no matching configuration for function vTaskResume() [checkLibraryFunction]
                vTaskResume(__run_handles[i]);
                ^
src/execute.h:148:9: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
        xEventGroupSync(xCreatedEventGroup,
        ^
src/execute.h:152:9: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
        vTaskDelay(10);
        ^
src/execute.h:153:9: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
        xEventGroupSync(xCreatedEventGroup2,
        ^
src/execute.h:236:16: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
    uxReturn = xEventGroupSync(xCreatedEventGroup,
               ^
src/execute.h:247:13: information: --check-library: There is no matching configuration for function xEventGroupClearBits() [checkLibraryFunction]
            xEventGroupClearBits(xCreatedEventGroup, MASK);
            ^
src/execute.h:258:13: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
            xEventGroupSync(xCreatedEventGroup2,
            ^
src/execute.h:268:13: information: --check-library: There is no matching configuration for function xEventGroupClearBits() [checkLibraryFunction]
            xEventGroupClearBits(xCreatedEventGroup2, MASK);
            ^
src/execute.h:273:9: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
        xEventGroupSync(xCreatedEventGroup2,
        ^
src/execute.h:393:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(10);
            ^
src/execute.h:396:17: information: --check-library: There is no matching configuration for function vTaskSuspend() [checkLibraryFunction]
                vTaskSuspend(*runningPrograms.getHandleByIndex(__run_handle_index));
                ^
src/execute.h:401:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(10);
            ^
src/execute.h:419:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(10);
            ^
src/execute.h:420:13: information: --check-library: There is no matching configuration for function vTaskResume() [checkLibraryFunction]
            vTaskResume(*runningPrograms.getHandleByIndex(__run_handle_index));
            ^
src/execute.h:438:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(10);
            ^
src/execute.h:444:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(30);
            ^
src/execute.h:448:17: information: --check-library: There is no matching configuration for function vTaskDelete() [checkLibraryFunction]
                vTaskDelete(*runningPrograms.getHandleByIndex(__run_handle_index));
                ^
src/execute.h:452:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(30);
            ^
src/execute.h:458:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(10);
            ^
src/execute.h:499:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(20);
            ^
src/execute.h:518:13: information: --check-library: There is no matching configuration for function xTaskCreateUniversal() [checkLibraryFunction]
            xTaskCreateUniversal(_run_task, taskname.c_str(), 4096 * 2, this, 3, (TaskHandle_t *)runningPrograms.getHandleByIndex(__run_handle_index), core);
            ^
src/execute.h:687:5: information: --check-library: There is no matching configuration for function vTaskDelete() [checkLibraryFunction]
    vTaskDelete(NULL);
    ^
src/ESPLiveScript.h:230:9: information: --check-library: There is no matching configuration for function displayStat() [checkLibraryFunction]
        displayStat("afterclen");
        ^
src/ESPLiveScript.h:497:33: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                    string sd = string(current_node->getTargetText());
                                ^
src/ESPLiveScript.h:541:21: information: --check-library: There is no matching configuration for function findMember() [checkLibraryFunction]
                i = findMember(current_node->getVarType(), string(current()->getText()));
                    ^
src/ESPLiveScript.h:541:60: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                i = findMember(current_node->getVarType(), string(current()->getText()));
                                                           ^
src/ESPLiveScript.h:553:56: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                i = findMember(current_node->_vartype, string(current()->getText()));
                                                       ^
src/ESPLiveScript.h:598:24: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
            current()->addText(string_format("%s.%s", search_result->getVarType()->varName.c_str(), current()->getText()));
                       ^
src/ESPLiveScript.h:639:77: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            current_node->getChildAtPos(current_node->children_size() - 1)->getChildAtPos(0)->getChildAtPos(0)->copyChildren(_node_token_stack.back());
                                                                            ^
src/ESPLiveScript.h:664:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(inputArgumentsNode));
                                     ^
src/ESPLiveScript.h:858:66: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                    else if (external_links[i].signature.compare(string(sav_t.back().getText())) == 0)
                                                                 ^
src/ESPLiveScript.h:979:50: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            if (search_result->getChildAtPos(1)->getChildAtPos(i)->_vartype == __Args__)
                                                 ^
src/ESPLiveScript.h:1016:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(current(), comparatorNode));
                                     ^
src/ESPLiveScript.h:1041:23: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node->addChild(NodeToken(statementNode));
                      ^
src/ESPLiveScript.h:1045:27: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node->addChild(NodeToken(current(), stringNode));
                          ^
src/ESPLiveScript.h:1061:31: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node->addChild(NodeToken(c, breakNode));
                              ^
src/ESPLiveScript.h:1084:31: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node->addChild(NodeToken(c, continueNode));
                              ^
src/ESPLiveScript.h:1100:31: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node->addChild(NodeToken(returnNode));
                              ^
src/ESPLiveScript.h:1106:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(returnNode));
                                             ^
src/ESPLiveScript.h:1192:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(assignementNode));
                                         ^
src/ESPLiveScript.h:1199:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(unitaryOpNode));
                                         ^
src/ESPLiveScript.h:1235:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(assignementNode));
                                         ^
src/ESPLiveScript.h:1316:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(binOpNode));
                                             ^
src/ESPLiveScript.h:1403:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(current(), elseNode, targetList.pop()));
                                         ^
src/ESPLiveScript.h:1455:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(&sav_t.back(), whileNode, targetList.get()));
                                             ^
src/ESPLiveScript.h:1529:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(current(), ifNode, targetList.get()));
                                             ^
src/ESPLiveScript.h:1601:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(current(), forNode, targetList.get()));
                                             ^
src/ESPLiveScript.h:1603:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(statementNode));
                                             ^
src/ESPLiveScript.h:1633:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(statementNode));
                                             ^
src/ESPLiveScript.h:1744:32: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                    current()->addText(string_format("%s._@%s()", nodeTokenList.get().getVarType()->varName.c_str(), nodeTokenList.get().getVarType()->varName.c_str()));
                               ^
src/ESPLiveScript.h:1784:35: information: --check-library: There is no matching configuration for function Context::findVariable() [checkLibraryFunction]
                    current_cntx->findVariable(nodeTokenList.get().getTokenText(), false);
                                  ^
src/ESPLiveScript.h:1795:32: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                    current()->addText(string_format("%s._@%s", search_result->getVarType()->varName.c_str(), current()->getText()));
                               ^
src/ESPLiveScript.h:1838:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(assignementNode));
                                             ^
src/ESPLiveScript.h:1946:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(current(), blockStatementNode));
                                     ^
src/ESPLiveScript.h:1985:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(defInputArgumentsNode));
                                     ^
src/ESPLiveScript.h:2309:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(ternaryIfNode));
                                         ^
src/ESPLiveScript.h:2347:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(binOpNode));
                                         ^
src/ESPLiveScript.h:2394:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(binOpNode));
                                         ^
src/ESPLiveScript.h:2447:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(testNode));
                                         ^
src/ESPLiveScript.h:2511:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(binOpNode));
                                         ^
src/ESPLiveScript.h:2565:27: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node->addChild(NodeToken(current(), numberNode));
                          ^
src/ESPLiveScript.h:2593:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(unitaryOpNode));
                                         ^
src/ESPLiveScript.h:2618:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(current(), changeTypeNode));
                                         ^
src/ESPLiveScript.h:2757:24: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
            current()->addText(string_format("%s._@%s", current()->getText(), current()->getText()));
                       ^
src/ESPLiveScript.h:2763:77: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            current_node->getChildAtPos(current_node->children_size() - 1)->getChildAtPos(2)->getChildAtPos(0)->copyChildren(_node_token_stack.back());
                                                                            ^
src/ESPLiveScript.h:2791:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(current(), numberNode));
                                         ^
src/ESPLiveScript.h:2862:40: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            program.addChildFront(nd)->addChild(NodeToken(current(), stringNode));
                                       ^
src/ESPLiveScript.h:2972:47: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                    sizestr = sizestr + " " + string(current()->getText());
                                              ^
src/ESPLiveScript.h:2990:51: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                        sizestr = sizestr + " " + string(current()->getText());
                                                  ^
src/ESPLiveScript.h:3106:40: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                            current()->addText(string_format("%s._@%s", usded.varName.c_str(), current()->getText()));
                                       ^
src/ESPLiveScript.h:3125:40: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                            current()->addText(string_format("%s.%s", usded.varName.c_str(), current()->getText()));
                                       ^
src/ESPLiveScript.h:3332:44: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                                current()->addText(string_format("%s._@%s()", current_node->getVarType()->varName.c_str(), current_node->getVarType()->varName.c_str()));
                                           ^
src/ESPLiveScript.h:3351:43: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                            current_node->addChild(NodeToken(current(), stringNode));
                                          ^
src/ESPLiveScript.h:3415:40: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                            current()->addText(string_format("%s._@%s", current_node->getVarType()->varName.c_str(), current()->getText()));
                                       ^
src/ESPLiveScript.h:3454:58: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                            current_node = current_node->addChild(NodeToken(assignementNode));
                                                         ^
src/asm_struct_enum.h:73:9: information: --check-library: There is no matching configuration for function push() [checkLibraryFunction]
        push(sav + 1);
        ^
src/asm_struct_enum.h:82:9: information: --check-library: There is no matching configuration for function push() [checkLibraryFunction]
        push(sav - 1);
        ^
src/asm_struct_enum.h:572:3: warning: Member variable 'result_parse_line::bincode' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:572:3: warning: Member variable 'result_parse_line::size' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:572:3: warning: Member variable 'result_parse_line::op' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:572:3: warning: Member variable 'result_parse_line::address' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:572:3: warning: Member variable 'result_parse_line::align' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:572:3: warning: Member variable 'result_parse_line::line' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:829:5: warning: Member variable '_arguments::intval' is not initialized in the constructor. [uninitMemberVar]
    _arguments()
    ^
src/asm_struct_enum.h:829:5: warning: Member variable '_arguments::floatval' is not initialized in the constructor. [uninitMemberVar]
    _arguments()
    ^
src/asm_struct_enum.h:833:5: warning: Member variable '_arguments::floatval' is not initialized in the constructor. [uninitMemberVar]
    _arguments(int val)
    ^
src/asm_struct_enum.h:838:5: warning: Member variable '_arguments::intval' is not initialized in the constructor. [uninitMemberVar]
    _arguments(float val)
    ^
src/tokenizer.h:873:5: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
    Token()
    ^
src/tokenizer.h:882:5: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
    Token(tokenType h)
    ^
src/tokenizer.h:890:5: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
    Token(tokenType _type, int __vartype, int _line)
    ^
src/tokenizer.h:899:5: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
    Token(tokenType _type, int __vartype)
    ^
src/tokenizer.h:965:5: warning: Member variable 'Tokens::_script' is not initialized in the constructor. [uninitMemberVar]
    Tokens()
    ^
src/execute.h:78:5: warning: Member variable '_executablesClass::nb_concurrent_programs_current' is not initialized in the constructor. [uninitMemberVar]
    _executablesClass()
    ^
src/execute.h:296:5: warning: Member variable 'Executable::error' is not initialized in the constructor. [uninitMemberVar]
    Executable()
    ^
src/execute.h:296:5: warning: Member variable 'Executable::df' is not initialized in the constructor. [uninitMemberVar]
    Executable()
    ^
src/execute.h:305:5: warning: Member variable 'Executable::__run_handle_index' is not initialized in the constructor. [uninitMemberVar]
    Executable(executable _executable)
    ^
src/execute.h:305:5: warning: Member variable 'Executable::error' is not initialized in the constructor. [uninitMemberVar]
    Executable(executable _executable)
    ^
src/execute.h:305:5: warning: Member variable 'Executable::df' is not initialized in the constructor. [uninitMemberVar]
    Executable(executable _executable)
    ^
src/asm_struct_enum.h:19:5: warning:inconclusive: Member variable 'Stack < int >::_default' is not initialized in the constructor. [uninitMemberVar]
    Stack() {}
    ^
src/asm_struct_enum.h:19:5: warning:inconclusive: Member variable 'Stack < varTypeEnum >::_default' is not initialized in the constructor. [uninitMemberVar]
    Stack() {}
    ^
src/asm_struct_enum.h:22:9: performance: Variable '_default' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        _default = def;
        ^
src/asm_struct_enum.h:210:12: style:inconclusive: Technically the member function 'Text::current' can be const. [functionConst]
    string current()
           ^
src/asm_struct_enum.h:237:12: style:inconclusive: Technically the member function 'Text::textAt' can be const. [functionConst]
    string textAt(int pos)
           ^
src/asm_struct_enum.h:385:9: style:inconclusive: Technically the member function 'Text::size' can be const. [functionConst]
    int size()
        ^
src/asm_struct_enum.h:434:9: style:inconclusive: Technically the member function 'Text::get' can be const. [functionConst]
    int get()
        ^
src/asm_struct_enum.h:870:9: style:inconclusive: Technically the member function 'Arguments::size' can be const. [functionConst]
    int size()
        ^
src/tokenizer.h:779:10: style:inconclusive: Technically the member function 'Script::currentChar' can be const. [functionConst]
    char currentChar()
         ^
src/tokenizer.h:908:15: style:inconclusive: Technically the member function 'Token::getType' can be const. [functionConst]
    tokenType getType()
              ^
src/tokenizer.h:982:9: style:inconclusive: Technically the member function 'Tokens::size' can be const. [functionConst]
    int size()
        ^
src/NodeToken.h:758:14: style:inconclusive: Technically the member function 'NodeToken::getNodeTokenType' can be const. [functionConst]
    nodeType getNodeTokenType()
             ^
src/NodeToken.h:762:9: style:inconclusive: Technically the member function 'NodeToken::children_size' can be const. [functionConst]
    int children_size()
        ^
src/NodeToken.h:1064:10: performance:inconclusive: Technically the member function 'Context::addFunction' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void addFunction(NodeToken *nd)
         ^
src/NodeToken.h:1105:10: performance:inconclusive: Technically the member function 'Context::findCandidate' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool findCandidate(char *str)
         ^
src/NodeToken.h:1132:10: performance:inconclusive: Technically the member function 'Context::findFunction' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void findFunction(Token *t)
         ^
src/execute.h:183:9: performance:inconclusive: Technically the member function '_executablesClass::getFirstHandle' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int getFirstHandle()
        ^
src/execute.h:550:10: style:inconclusive: Technically the member function 'Executable::isExeExists' can be const. [functionConst]
    bool isExeExists()
         ^
src/execute.h:641:10: style:inconclusive: Technically the member function 'Executable::isRunning' can be const. [functionConst]
    bool isRunning()
         ^
src/ESPLiveScript.h:93:9: performance:inconclusive: Technically the member function 'Parser::size' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int size()
        ^
src/ESPLiveScript.h:117:10: performance:inconclusive: Technically the member function 'Parser::Match' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool Match(tokenType tt)
         ^
src/ESPLiveScript.h:121:10: performance:inconclusive: Technically the member function 'Parser::Match' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool Match(tokenType tt, int index)
         ^
src/asm_struct_enum.h:833:5: style: Class '_arguments' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    _arguments(int val)
    ^
src/asm_struct_enum.h:838:5: style: Class '_arguments' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    _arguments(float val)
    ^
src/tokenizer.h:882:5: style: Class 'Token' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Token(tokenType h)
    ^
src/NodeToken.h:433:5: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    NodeToken(nodeType tt)
    ^
src/NodeToken.h:446:5: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    NodeToken(Token *t)
    ^
src/NodeToken.h:529:5: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    NodeToken(NodeToken *nd)
    ^
src/execute.h:305:5: style: Class 'Executable' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Executable(executable _executable)
    ^
src/asm_struct_enum.h:20:5: style: Class 'Stack < int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Stack(T def)
    ^
src/asm_struct_enum.h:20:5: style: Class 'Stack < NodeToken >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Stack(T def)
    ^
src/asm_struct_enum.h:20:5: style: Class 'Stack < string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Stack(T def)
    ^
src/asm_struct_enum.h:20:5: style: Class 'Stack < varTypeEnum >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Stack(T def)
    ^
src/asm_struct_enum.h:310:21: style: Condition '_pos>-1' is always false [knownConditionTrueFalse]
             if(_pos>-1 && _texts[_pos]!=NULL)
                    ^
src/asm_struct_enum.h:309:20: note: Assignment '_pos=-1', assigned value is -1
             _pos=-1;
                   ^
src/asm_struct_enum.h:310:21: note: Condition '_pos>-1' is always false
             if(_pos>-1 && _texts[_pos]!=NULL)
                    ^
src/NodeToken.h:3233:11: style: Condition 't==NULL' is always false [knownConditionTrueFalse]
    if (t == NULL)
          ^
src/NodeToken.h:3216:12: note: Assuming that condition 'nd==NULL' is not redundant
    if (nd == NULL)
           ^
src/NodeToken.h:3232:20: note: Assignment 't=nd', assigned value is 0
    NodeToken *t = nd; // cntx.findFunction(nd->_token);
                   ^
src/NodeToken.h:3233:11: note: Condition 't==NULL' is always false
    if (t == NULL)
          ^
src/execute.h:435:20: style: Condition '!toResetSync' is always false [knownConditionTrueFalse]
            while (!toResetSync)
                   ^
src/execute.h:434:27: note: Assignment 'toResetSync=true', assigned value is 1
            toResetSync = true;
                          ^
src/execute.h:435:20: note: Condition '!toResetSync' is always false
            while (!toResetSync)
                   ^
src/NodeToken.h:4067:25: warning: %lu in format string (no. 1) requires 'unsigned long *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
                        sscanf(ndt->getTokenText(), "%lu", &__num);
                        ^
src/execute.h:543:13: warning: %ld in format string (no. 1) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            printf("Free memory after:%ld freed:%ld\r\n", mema, mema - memb);
            ^
src/execute.h:543:13: warning: %ld in format string (no. 2) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            printf("Free memory after:%ld freed:%ld\r\n", mema, mema - memb);
            ^
src/asm_struct_enum.h:625:5: information: --check-library: Function push_back() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return parsed_lines.back();
    ^
src/tokenizer.h:990:55: information: --check-library: Function tokenizer() should have <noreturn> configuration [checkLibraryNoReturn]
        tokenizer(script, true, increae_line, nbToken);
                                                      ^
src/tokenizer.h:999:57: information: --check-library: Function tokenizer() should have <noreturn> configuration [checkLibraryNoReturn]
        tokenizer(script, update, increae_line, nbToken);
                                                        ^
src/NodeToken.h:26:52: information: --check-library: Function ESP_LOGD() should have <noreturn> configuration [checkLibraryNoReturn]
    ESP_LOGD("ESPLiveScript","%s\r\n", str.c_str());
                                                   ^
src/NodeToken.h:36:30: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    pushToConsole(str, false);
                             ^
src/NodeToken.h:124:274: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    pushToConsole(string_format(" %s :max used memory: %ld maxstack:%ld  started %d free mem:%ld consumed %ld time:%dms",text, __maxMemUsage, __MaxStackMemory, __startmem, esp_get_free_heap_size(), __startmem - esp_get_free_heap_size(), (__endtime - __starttime) / 240000));
                                                                                                                                                                                                                                                                                 ^
src/NodeToken.h:128:16: information: --check-library: Function displayStat() should have <noreturn> configuration [checkLibraryNoReturn]
displayStat("");
               ^
src/NodeToken.h:1966:64: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
        translateType(globalType.get(), r, register_numr.get());
                                                               ^
src/NodeToken.h:2433:82: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
                translateType(globalType.get(), v->_varType, register_numl.get());
                                                                                 ^
src/NodeToken.h:2782:111: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
            translateType(globalType.get(), nd->getChildAtPos(1)->getVarType()->_varType, register_numl.get());
                                                                                                              ^
src/NodeToken.h:3625:50: information: --check-library: Function _visitCallFunctionTemplate() should have <noreturn> configuration [checkLibraryNoReturn]
        _visitCallFunctionTemplate(nd, 10, false);
                                                 ^
src/NodeToken.h:3807:106: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
                translateType(__int__, nd->getChildAtPos(0)->getVarType()->_varType, register_numl.get());
                                                                                                         ^
src/execute_asm.h:9:37: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(bin->binary_data);
                                    ^
src/execute_asm.h:11:39: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(bin->function_data);
                                      ^
src/execute_asm.h:189:5: information: --check-library: Function decodeBinaryHeader() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return exe;
    ^
src/execute_asm.h:197:5: information: --check-library: Function decodeBinaryHeader() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return exe;
    ^
src/execute_asm.h:335:9: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
      :);
        ^
src/execute_asm.h:413:46: information: --check-library: Function heap_caps_aligned_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_aligned_free(ex->start_program);
                                             ^
src/execute_asm.h:421:29: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(ex->data);
                            ^
src/execute_asm.h:446:89: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    pushToConsole(string_format("Overflow error  max size: %d got %d", size, got), true);
                                                                                        ^
src/execute_asm.h:683:90: information: --check-library: Function addExternalFunction() should have <noreturn> configuration [checkLibraryNoReturn]
        addExternalFunction("error", "void", "int,uint32_t,uint32_t", (void *)&showError);
                                                                                         ^
src/execute.h:70:18: information: --check-library: Function vTaskDelay() should have <noreturn> configuration [checkLibraryNoReturn]
    vTaskDelay(1);
                 ^
src/execute.h:156:39: information: --check-library: Function xEventGroupSync() should have <noreturn> configuration [checkLibraryNoReturn]
                        portMAX_DELAY);
                                      ^
src/execute.h:205:27: information: --check-library: Function _prekill() should have <noreturn> configuration [checkLibraryNoReturn]
                _prekill();
                          ^
src/execute.h:213:28: information: --check-library: Function _postkill() should have <noreturn> configuration [checkLibraryNoReturn]
                _postkill();
                           ^
src/execute.h:268:60: information: --check-library: Function xEventGroupClearBits() should have <noreturn> configuration [checkLibraryNoReturn]
            xEventGroupClearBits(xCreatedEventGroup2, MASK);
                                                           ^
src/execute.h:276:39: information: --check-library: Function xEventGroupSync() should have <noreturn> configuration [checkLibraryNoReturn]
                        portMAX_DELAY);
                                      ^
src/execute.h:373:41: information: --check-library: Function freeExecutable() should have <noreturn> configuration [checkLibraryNoReturn]
            freeExecutable(&_executecmd);
                                        ^
src/execute.h:396:84: information: --check-library: Function vTaskSuspend() should have <noreturn> configuration [checkLibraryNoReturn]
                vTaskSuspend(*runningPrograms.getHandleByIndex(__run_handle_index));
                                                                                   ^
src/execute.h:404:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole("Program Halted.", true);
                                                  ^
src/execute.h:511:65: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
                pushToConsole("too many programs at once", true);
                                                                ^
src/execute.h:520:71: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole("Execution on going CTRL + k to stop", true);
                                                                      ^
src/execute.h:524:55: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole("Nothing to execute.", true);
                                                      ^
src/execute.h:563:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole(res.error_message, true);
                                                  ^
src/execute.h:577:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole(res.error_message, true);
                                                  ^
src/execute.h:670:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole(res.error_message, true);
                                                  ^
src/execute.h:679:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole(res.error_message, true);
                                                  ^
src/execute.h:687:22: information: --check-library: Function vTaskDelete() should have <noreturn> configuration [checkLibraryNoReturn]
    vTaskDelete(NULL);
                     ^
src/execute.h:735:71: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole("please add a name to the executable", true);
                                                                      ^
src/ESPLiveScript.h:282:77: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
                pushToConsole(_executecmd.error.error_message.c_str(), true);
                                                                            ^
src/asm_struct_enum.h:73:22: information: --check-library: Function push() should have <noreturn> configuration [checkLibraryNoReturn]
        push(sav + 1);
                     ^
src/asm_struct_enum.h:82:22: information: --check-library: Function push() should have <noreturn> configuration [checkLibraryNoReturn]
        push(sav - 1);
                     ^
src/NodeToken.h:1556:12: warning: Either the condition 'p!=NULL' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]
    while (p->_nodetype != forNode and p->_nodetype != whileNode)
           ^
src/NodeToken.h:1562:11: note: Assuming that condition 'p!=NULL' is not redundant
    if (p != NULL)
          ^
src/NodeToken.h:1556:12: note: Null pointer dereference
    while (p->_nodetype != forNode and p->_nodetype != whileNode)
           ^
src/NodeToken.h:3212:26: warning: Either the condition 'nd==NULL' is redundant or there is possible null pointer dereference: nd. [nullPointerRedundantCheck]
    int staack_offset = (nd->getChildAtPos(0)->children_size() - 7) * 4;
                         ^
src/NodeToken.h:3216:12: note: Assuming that condition 'nd==NULL' is not redundant
    if (nd == NULL)
           ^
src/NodeToken.h:3212:26: note: Null pointer dereference
    int staack_offset = (nd->getChildAtPos(0)->children_size() - 7) * 4;
                         ^
src/NodeToken.h:3637:9: warning: Either the condition 'v==NULL' is redundant or there is possible null pointer dereference: v. [nullPointerRedundantCheck]
    if (v->size > 1)
        ^
src/NodeToken.h:3631:11: note: Assuming that condition 'v==NULL' is not redundant
    if (v == NULL)
          ^
src/NodeToken.h:3637:9: note: Null pointer dereference
    if (v->size > 1)
        ^
src/asm_struct_enum.h:622:28: style: C-style pointer casting [cstyleCast]
    result_parse_line *tmp=(result_parse_line *)malloc(sizeof(result_parse_line));
                           ^
src/asm_struct_enum.h:650:26: style: C-style pointer casting [cstyleCast]
  result_parse_line *tmp=(result_parse_line *)malloc(sizeof(result_parse_line));
                         ^
src/execute.h:657:25: style: C-style pointer casting [cstyleCast]
    Executable *exec = ((Executable *)pvParameters);
                        ^
src/NodeToken.h:1690:43: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
            uint32_t __num = (uint32_t)(*((uint32_t *)&__f));
                                          ^
src/NodeToken.h:4062:46: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                        __num = (uint32_t)(*((uint32_t *)&__f));
                                             ^
src/asm_struct_enum.h:309:18: style: Redundant initialization for '_pos'. The initialized value is overwritten before it is read. [redundantInitialization]
             _pos=-1;
                 ^
src/asm_struct_enum.h:308:23: note: _pos is initialized
             int _pos = findText((char *)str.c_str());
                      ^
src/asm_struct_enum.h:309:18: note: _pos is overwritten
             _pos=-1;
                 ^
src/execute.h:574:13: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
        res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
            ^
src/execute.h:572:34: note: res is initialized
        error_message_struct res = executeBinary("@__footer", _executecmd, 9999, this, d);
                                 ^
src/execute.h:574:13: note: res is overwritten
        res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
            ^
src/execute.h:667:13: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
        res = executeBinary(exec->df.args[0], exec->df.exe, exec->__run_handle_index, exec, exec->args);
            ^
src/execute.h:665:34: note: res is initialized
        error_message_struct res = executeBinary("@__footer", exec->df.exe, exec->__run_handle_index, exec, d);
                                 ^
src/execute.h:667:13: note: res is overwritten
        res = executeBinary(exec->df.args[0], exec->df.exe, exec->__run_handle_index, exec, exec->args);
            ^
src/execute.h:676:13: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
        res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec, exec->args);
            ^
src/execute.h:675:34: note: res is initialized
        error_message_struct res = executeBinary("@__footer", exec->df.exe, exec->__run_handle_index, exec, d);
                                 ^
src/execute.h:676:13: note: res is overwritten
        res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec, exec->args);
            ^
src/ESPLiveScript.h:131:22: style: Variable 'point_regnum' is reassigned a value before the old one has been used. [redundantAssignment]
        point_regnum = 4;
                     ^
src/ESPLiveScript.h:130:22: note: point_regnum is assigned
        point_regnum = 4;
                     ^
src/ESPLiveScript.h:131:22: note: point_regnum is overwritten
        point_regnum = 4;
                     ^
src/NodeToken.h:3223:9: style:inconclusive: Found duplicate branches for 'if' and 'else'. [duplicateBranch]
        if (isExtCall)
        ^
src/NodeToken.h:3225:9: note: Found duplicate branches for 'if' and 'else'.
        else
        ^
src/NodeToken.h:3223:9: note: Found duplicate branches for 'if' and 'else'.
        if (isExtCall)
        ^
src/NodeToken.h:4693:13: style:inconclusive: Found duplicate branches for 'if' and 'else'. [duplicateBranch]
            if (strlen(nd->getChildAtPos(i)->getTokenText()) > 0)
            ^
src/NodeToken.h:4695:13: note: Found duplicate branches for 'if' and 'else'.
            else
            ^
src/NodeToken.h:4693:13: note: Found duplicate branches for 'if' and 'else'.
            if (strlen(nd->getChildAtPos(i)->getTokenText()) > 0)
            ^
src/NodeToken.h:1532:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        break;
        ^
src/NodeToken.h:1647:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        break;
        ^
src/NodeToken.h:3588:25: style: The scope of the variable 'sav' can be reduced. [variableScope]
                    int sav;
                        ^
src/NodeToken.h:3900:9: style: The scope of the variable 'sav' can be reduced. [variableScope]
    int sav = 9;
        ^
src/NodeToken.h:4053:21: style: The scope of the variable 'c' can be reduced. [variableScope]
            uint8_t c;
                    ^
src/NodeToken.h:4987:29: style: The scope of the variable 'ind' can be reduced. [variableScope]
                        int ind = -1;
                            ^
src/asm_parser.h:82:9: style: The scope of the variable 'add_size' can be reduced. [variableScope]
    int add_size = 0;
        ^
src/asm_parser.h:452:12: style: The scope of the variable 'values' can be reduced. [variableScope]
  uint32_t values[4];
           ^
src/execute_asm.h:250:8: style: The scope of the variable 'ver' can be reduced. [variableScope]
  char ver[19];
       ^
src/ESPLiveScript.h:2961:17: style: The scope of the variable 'j' can be reduced. [variableScope]
            int j = 0;
                ^
src/execute.h:693:34: style:inconclusive: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'. [funcArgNamesDifferent]
void _executablesClass::kill(int handle_number)
                                 ^
src/execute.h:116:19: note: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'.
    void kill(int handle);
                  ^
src/execute.h:693:34: note: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'.
void _executablesClass::kill(int handle_number)
                                 ^
src/tokenizer.h:1944:18: style: Local variable 'c2' shadows outer variable [shadowVariable]
            char c2 = script->nextChar();
                 ^
src/tokenizer.h:1299:10: note: Shadowed declaration
    char c2;
         ^
src/tokenizer.h:1944:18: note: Shadow variable
            char c2 = script->nextChar();
                 ^
src/tokenizer.h:2123:26: style: Local variable 'c2' shadows outer variable [shadowVariable]
                    char c2 = script->nextChar();
                         ^
src/tokenizer.h:1299:10: note: Shadowed declaration
    char c2;
         ^
src/tokenizer.h:2123:26: note: Shadow variable
                    char c2 = script->nextChar();
                         ^
src/NodeToken.h:1066:20: style: Local variable '__tmpToken' shadows outer variable [shadowVariable]
        NodeToken *__tmpToken = new NodeToken();
                   ^
src/NodeToken.h:408:12: note: Shadowed declaration
NodeToken *__tmpToken;
           ^
src/NodeToken.h:1066:20: note: Shadow variable
        NodeToken *__tmpToken = new NodeToken();
                   ^
src/NodeToken.h:2487:13: style: Local variable 'start' shadows outer variable [shadowVariable]
        int start = nd->stack_pos;
            ^
src/NodeToken.h:2474:9: note: Shadowed declaration
    int start = nd->stack_pos;
        ^
src/NodeToken.h:2487:13: note: Shadow variable
        int start = nd->stack_pos;
            ^
src/NodeToken.h:3912:21: style: Local variable 'start' shadows outer variable [shadowVariable]
                int start = nd->getChildAtPos(i)->stack_pos;
                    ^
src/NodeToken.h:3908:17: note: Shadowed declaration
            int start = nd->getChildAtPos(i)->stack_pos;
                ^
src/NodeToken.h:3912:21: note: Shadow variable
                int start = nd->getChildAtPos(i)->stack_pos;
                    ^
src/NodeToken.h:4862:32: style: Local variable 'd2' shadows outer variable [shadowVariable]
                vector<string> d2 = split(tmp, " ");
                               ^
src/NodeToken.h:4794:20: note: Shadowed declaration
    vector<string> d2;
                   ^
src/NodeToken.h:4862:32: note: Shadow variable
                vector<string> d2 = split(tmp, " ");
                               ^
src/NodeToken.h:4867:36: style: Local variable 'd' shadows outer variable [shadowVariable]
                    vector<string> d = split(before, " ");
                                   ^
src/NodeToken.h:4793:20: note: Shadowed declaration
    vector<string> d;
                   ^
src/NodeToken.h:4867:36: note: Shadow variable
                    vector<string> d = split(before, " ");
                                   ^
src/NodeToken.h:4988:30: style: Local variable 'found' shadows outer variable [shadowVariable]
                        bool found = false;
                             ^
src/NodeToken.h:64:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:4988:30: note: Shadow variable
                        bool found = false;
                             ^
src/NodeToken.h:5031:30: style: Local variable 'found' shadows outer variable [shadowVariable]
                        bool found = false;
                             ^
src/NodeToken.h:64:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5031:30: note: Shadow variable
                        bool found = false;
                             ^
src/NodeToken.h:5127:30: style: Local variable 'found' shadows outer variable [shadowVariable]
                        bool found = false;
                             ^
src/NodeToken.h:64:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5127:30: note: Shadow variable
                        bool found = false;
                             ^
src/NodeToken.h:5181:30: style: Local variable 'found' shadows outer variable [shadowVariable]
                        bool found = false;
                             ^
src/NodeToken.h:64:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5181:30: note: Shadow variable
                        bool found = false;
                             ^
src/NodeToken.h:5235:30: style: Local variable 'found' shadows outer variable [shadowVariable]
                        bool found = false;
                             ^
src/NodeToken.h:64:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5235:30: note: Shadow variable
                        bool found = false;
                             ^
src/asm_parser.h:1287:22: style: Local variable '__v' shadows outer variable [shadowVariable]
      vector<string> __v = split(trim(str), " ");
                     ^
src/tokenizer.h:63:9: note: Shadowed declaration
varType __v;
        ^
src/asm_parser.h:1287:22: note: Shadow variable
      vector<string> __v = split(trim(str), " ");
                     ^
src/execute_asm.h:54:16: style: Local variable 'content' shadows outer variable [shadowVariable]
      uint32_t content = bincode + address;
               ^
src/NodeToken.h:354:6: note: Shadowed declaration
Text content;
     ^
src/execute_asm.h:54:16: note: Shadow variable
      uint32_t content = bincode + address;
               ^
src/execute_asm.h:72:18: style: Local variable 'content' shadows outer variable [shadowVariable]
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/NodeToken.h:354:6: note: Shadowed declaration
Text content;
     ^
src/execute_asm.h:72:18: note: Shadow variable
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/execute_asm.h:109:18: style: Local variable 'content' shadows outer variable [shadowVariable]
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/NodeToken.h:354:6: note: Shadowed declaration
Text content;
     ^
src/execute_asm.h:109:18: note: Shadow variable
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/execute_asm.h:371:18: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (int i = 1; i < args.size(); i++)
                 ^
src/execute_asm.h:345:12: note: Shadowed declaration
  for (int i = 0; i < ex.functions.size(); i++)
           ^
src/execute_asm.h:371:18: note: Shadow variable
        for (int i = 1; i < args.size(); i++)
                 ^
src/ESPLiveScript.h:374:30: style: Local variable 'i' shadows outer variable [shadowVariable]
                    for (int i = 0; i < __DEPTH; i++)
                             ^
src/ESPLiveScript.h:358:22: note: Shadowed declaration
            for (int i = 0; i < external_links.size(); i++)
                     ^
src/ESPLiveScript.h:374:30: note: Shadow variable
                    for (int i = 0; i < __DEPTH; i++)
                             ^
src/ESPLiveScript.h:475:30: style: Local variable 'nd' shadows outer variable [shadowVariable]
                   NodeToken nd = NodeToken(changeTypeNode);
                             ^
src/ESPLiveScript.h:444:22: note: Shadowed declaration
           NodeToken nd = NodeToken(changeTypeNode);
                     ^
src/ESPLiveScript.h:475:30: note: Shadow variable
                   NodeToken nd = NodeToken(changeTypeNode);
                             ^
src/ESPLiveScript.h:731:20: style: Local variable '_signature' shadows outer variable [shadowVariable]
            string _signature = sigs.back() + "*";
                   ^
src/ESPLiveScript.h:725:16: note: Shadowed declaration
        string _signature = sigs.back() + current_node->getVarType()->varName;
               ^
src/ESPLiveScript.h:731:20: note: Shadow variable
            string _signature = sigs.back() + "*";
                   ^
src/ESPLiveScript.h:746:22: style: Local variable 'nd' shadows outer variable [shadowVariable]
           NodeToken nd =NodeToken(changeTypeNode);
                     ^
src/ESPLiveScript.h:712:19: note: Shadowed declaration
        NodeToken nd = NodeToken(changeTypeNode);
                  ^
src/ESPLiveScript.h:746:22: note: Shadow variable
           NodeToken nd =NodeToken(changeTypeNode);
                     ^
src/ESPLiveScript.h:758:20: style: Local variable '_signature' shadows outer variable [shadowVariable]
            string _signature = sigs.back() + "|" + current_node->getVarType()->varName;
                   ^
src/ESPLiveScript.h:725:16: note: Shadowed declaration
        string _signature = sigs.back() + current_node->getVarType()->varName;
               ^
src/ESPLiveScript.h:758:20: note: Shadow variable
            string _signature = sigs.back() + "|" + current_node->getVarType()->varName;
                   ^
src/ESPLiveScript.h:764:24: style: Local variable '_signature' shadows outer variable [shadowVariable]
                string _signature = sigs.back() + "*";
                       ^
src/ESPLiveScript.h:758:20: note: Shadowed declaration
            string _signature = sigs.back() + "|" + current_node->getVarType()->varName;
                   ^
src/ESPLiveScript.h:764:24: note: Shadow variable
                string _signature = sigs.back() + "*";
                       ^
src/ESPLiveScript.h:2064:23: style: Local variable '_nd' shadows outer variable [shadowVariable]
            NodeToken _nd = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:2022:19: note: Shadowed declaration
        NodeToken _nd = nodeTokenList.pop();
                  ^
src/ESPLiveScript.h:2064:23: note: Shadow variable
            NodeToken _nd = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:2066:23: style: Local variable '_t' shadows outer variable [shadowVariable]
            NodeToken _t = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:2024:19: note: Shadowed declaration
        NodeToken _t = nodeTokenList.pop();
                  ^
src/ESPLiveScript.h:2066:23: note: Shadow variable
            NodeToken _t = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:3179:43: style: Local variable 'nd' shadows outer variable [shadowVariable]
                                NodeToken nd = NodeToken(current(), defLocalVariableNode);
                                          ^
src/ESPLiveScript.h:3150:39: note: Shadowed declaration
                            NodeToken nd = NodeToken(current(), defLocalVariableNode);
                                      ^
src/ESPLiveScript.h:3179:43: note: Shadow variable
                                NodeToken nd = NodeToken(current(), defLocalVariableNode);
                                          ^
src/ESPLiveScript.h:3294:43: style: Local variable 'nd' shadows outer variable [shadowVariable]
                                NodeToken nd = nodeTokenList.pop();
                                          ^
src/ESPLiveScript.h:3265:35: note: Shadowed declaration
                        NodeToken nd = nodeTokenList.pop();
                                  ^
src/ESPLiveScript.h:3294:43: note: Shadow variable
                                NodeToken nd = nodeTokenList.pop();
                                          ^
src/ESPLiveScript.h:3295:43: style: Local variable '_t' shadows outer variable [shadowVariable]
                                NodeToken _t = nodeTokenList.pop();
                                          ^
src/ESPLiveScript.h:3266:35: note: Shadowed declaration
                        NodeToken _t = nodeTokenList.pop();
                                  ^
src/ESPLiveScript.h:3295:43: note: Shadow variable
                                NodeToken _t = nodeTokenList.pop();
                                          ^
src/ESPLiveScript.h:3416:39: style: Local variable 'nd' shadows outer variable [shadowVariable]
                            NodeToken nd = NodeToken(*current_node);
                                      ^
src/ESPLiveScript.h:3265:35: note: Shadowed declaration
                        NodeToken nd = nodeTokenList.pop();
                                  ^
src/ESPLiveScript.h:3416:39: note: Shadow variable
                            NodeToken nd = NodeToken(*current_node);
                                      ^
src/ESPLiveScript.h:3451:39: style: Local variable 'nd' shadows outer variable [shadowVariable]
                            NodeToken nd = NodeToken(*current_node);
                                      ^
src/ESPLiveScript.h:3265:35: note: Shadowed declaration
                        NodeToken nd = nodeTokenList.pop();
                                  ^
src/ESPLiveScript.h:3451:39: note: Shadow variable
                            NodeToken nd = NodeToken(*current_node);
                                      ^
src/asm_struct_enum.h:152:35: performance: Function parameter 's' should be passed by const reference. [passedByValue]
    void addAfter(int pos, string s)
                                  ^
src/asm_struct_enum.h:164:36: performance: Function parameter 's' should be passed by const reference. [passedByValue]
    void addBefore(int pos, string s)
                                   ^
src/tokenizer.h:546:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalDefine(string name,string content)
                              ^
src/tokenizer.h:546:43: performance: Function parameter 'content' should be passed by const reference. [passedByValue]
void addExternalDefine(string name,string content)
                                          ^
src/tokenizer.h:1142:25: performance: Function parameter 't' should be passed by const reference. [passedByValue]
void displaytoken(token t)
                        ^
src/asm_external.h:25:33: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalFunction(string name,string out,string in, void * ptr)
                                ^
src/asm_external.h:25:56: performance: Function parameter 'in' should be passed by const reference. [passedByValue]
void addExternalFunction(string name,string out,string in, void * ptr)
                                                       ^
src/asm_external.h:67:33: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out,string in,void * ptr)
                                ^
src/asm_external.h:67:46: performance: Function parameter 'out' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out,string in,void * ptr)
                                             ^
src/asm_external.h:67:57: performance: Function parameter 'in' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out,string in,void * ptr)
                                                        ^
src/asm_external.h:78:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternal(string name, externalType type, void * ptr)
                        ^
src/NodeToken.h:34:27: performance: Function parameter 'str' should be passed by const reference. [passedByValue]
void pushToConsole(string str)
                          ^
src/NodeToken.h:543:22: performance: Function parameter '_target' should be passed by const reference. [passedByValue]
    NodeToken(string _target, nodeType tt)
                     ^
src/NodeToken.h:549:49: performance: Function parameter '_target' should be passed by const reference. [passedByValue]
    NodeToken(NodeToken nd, nodeType tt, string _target)
                                                ^
src/asm_parser.h:448:41: performance: Function parameter 'str' should be passed by const reference. [passedByValue]
result_parse_line parseOperandes(string str, int nboperande, operandeType *optypes, int size, uint32_t (*createbin)(uint32_t *val))
                                        ^
src/asm_parser.h:494:22: performance: Function parameter 's' should be passed by const reference. [passedByValue]
int findLabel(string s, parsedLines *asm_parsed)
                     ^
src/execute.h:472:29: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
    int _run(vector<string> args, bool second_core, int core, Arguments arguments)
                            ^
src/execute.h:472:73: performance: Function parameter 'arguments' should be passed by const reference. [passedByValue]
    int _run(vector<string> args, bool second_core, int core, Arguments arguments)
                                                                        ^
src/execute.h:555:29: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void executeOnly(string prog)
                            ^
src/execute.h:567:25: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void execute(string prog)
                        ^
src/execute.h:582:25: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void execute(string prog, Arguments arguments)
                        ^
src/execute.h:604:31: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void executeAsTask(string prog, int core, Arguments arguments)
                              ^
src/execute.h:625:31: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void executeAsTask(string prog, Arguments arguments)
                              ^
src/execute.h:625:47: performance: Function parameter 'arguments' should be passed by const reference. [passedByValue]
    void executeAsTask(string prog, Arguments arguments)
                                              ^
src/execute.h:629:31: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void executeAsTask(string prog)
                              ^
src/execute.h:635:31: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void executeAsTask(string prog, int core)
                              ^
src/execute.h:738:39: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void addExe(Executable df, string name)
                                      ^
src/execute.h:755:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void execute(string name)
                        ^
src/execute.h:766:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void execute(string name, string function)
                        ^
src/execute.h:777:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void execute(string name, Arguments arguments)
                        ^
src/execute.h:789:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void execute(string name, string function, Arguments arguments)
                        ^
src/execute.h:800:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name, Arguments arguments)
                              ^
src/execute.h:811:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name)
                              ^
src/execute.h:823:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name, string function, Arguments arguments)
                              ^
src/execute.h:834:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name, string function)
                              ^
src/execute.h:845:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name, int core, Arguments args)
                              ^
src/execute.h:856:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name, int core)
                              ^
src/execute.h:867:22: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void kill(string name)
                     ^
src/execute.h:898:22: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void free(string name)
                     ^
src/execute.h:939:39: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    exe_info getExecutableInfo(string name)
                                      ^
src/asm_struct_enum.h:20:13: performance: Function parameter 'def' should be passed by const reference. [passedByValue]
    Stack(T def)
            ^
src/ESPLiveScript.h:184:13: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
            pushToConsole(Error.error_message.c_str(), true);
            ^
src/ESPLiveScript.h:253:13: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
            pushToConsole(bin.error.error_message.c_str(), true);
            ^
src/ESPLiveScript.h:282:17: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
                pushToConsole(_executecmd.error.error_message.c_str(), true);
                ^
src/NodeToken.h:1273:17: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                {
                ^
src/NodeToken.h:1298:17: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                {
                ^
src/asm_external.h:65:30: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_external.h:65:30: error: Uninitialized struct member: asmex.offset [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_external.h:76:30: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_external.h:76:30: error: Uninitialized struct member: asmex.offset [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_external.h:86:30: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_external.h:86:30: error: Uninitialized struct member: asmex.offset [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_parser.h:163:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:171:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:163:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:171:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:197:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:205:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:197:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:205:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:231:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:239:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:231:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:239:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:263:23: error: Uninitialized struct member: error.line [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:271:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:263:23: error: Uninitialized struct member: error.pos [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:271:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:295:23: error: Uninitialized struct member: error.line [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:303:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:295:23: error: Uninitialized struct member: error.pos [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:303:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:322:19: error: Uninitialized struct member: error.line [uninitStructMember]
      res.error = error;
                  ^
src/asm_parser.h:328:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:322:19: error: Uninitialized struct member: error.pos [uninitStructMember]
      res.error = error;
                  ^
src/asm_parser.h:328:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:1222:15: error: Uninitialized struct member: err.line [uninitStructMember]
  asm_Error = err;
              ^
src/asm_parser.h:1222:15: error: Uninitialized struct member: err.pos [uninitStructMember]
  asm_Error = err;
              ^
src/execute.h:952:16: error: Uninitialized variable: inf [uninitvar]
        return inf;
               ^
src/execute.h:944:15: note: Assuming condition is false
        if (f != NULL)
              ^
src/execute.h:952:16: note: Uninitialized variable: inf
        return inf;
               ^
src/execute.h:959:20: error: Uninitialized variable: inf [uninitvar]
            return inf;
                   ^
src/NodeToken.h:627:19: style: Variable 'nd.parent' is assigned a value that is never used. [unreadVariable]
        nd.parent = this;
                  ^
src/NodeToken.h:1110:15: style: Unused variable: tocmp [unusedVariable]
        char *tocmp;
              ^
src/NodeToken.h:1137:15: style: Unused variable: tocmp [unusedVariable]
        char *tocmp;
              ^
src/NodeToken.h:2627:13: style: Variable 'sav' is assigned a value that is never used. [unreadVariable]
    int sav = 9;
            ^
src/NodeToken.h:3215:17: style: Variable 'nbfloat' is assigned a value that is never used. [unreadVariable]
    int nbfloat = 0;
                ^
src/NodeToken.h:3850:18: style: Variable 't' is assigned a value that is never used. [unreadVariable]
    NodeToken *t = nd;
                 ^
src/NodeToken.h:4052:19: style: Variable '__num' is assigned a value that is never used. [unreadVariable]
            __num = 0;
                  ^
src/asm_parser.h:82:18: style: Variable 'add_size' is assigned a value that is never used. [unreadVariable]
    int add_size = 0;
                 ^
src/execute_asm.h:34:9: style: Unused variable: textptr2 [unusedVariable]
  char *textptr2;
        ^
src/ESPLiveScript.h:3053:23: style: Variable 'memberpos' is assigned a value that is never used. [unreadVariable]
        int memberpos = 0;
                      ^
src/ESPLiveScript.h:3054:20: style: Variable '_start' is assigned a value that is never used. [unreadVariable]
        int _start = 0;
                   ^
src/ESPLiveScript.h:3055:18: style: Variable '_pos' is assigned a value that is never used. [unreadVariable]
        int _pos = 0;
                 ^
main.cpp:15:17: style: Variable 'exec' is assigned a value that is never used. [unreadVariable]
 Executable exec=_parser.parseScript(&script);
                ^
src/asm_struct_enum.h:195:13: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
            _it--;
            ^
src/asm_struct_enum.h:296:9: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        _it++;
        ^
src/asm_struct_enum.h:332:80: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        for (vector<char *>::iterator it = _texts.begin(); it != _texts.end(); it++)
                                                                               ^
src/asm_struct_enum.h:431:13: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
            _it--;
            ^
src/tokenizer.h:807:17: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                it--;
                ^
src/tokenizer.h:831:9: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        it++;
        ^
src/tokenizer.h:841:82: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        for (vector<char *>::iterator _it = script.begin(); _it != script.end(); _it++)
                                                                                 ^
src/tokenizer.h:856:13: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
            it++;
            ^
src/asm_external.h:91:91: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
     for(vector<asm_external>::iterator it=external_links.begin();it<external_links.end();it++)
                                                                                          ^
src/NodeToken.h:1578:103: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        for (vector<NodeToken *>::iterator it = __nd->children->begin(); it != __nd->children->end(); it++)
                                                                                                      ^
src/asm_parser.h:112:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = _asm_parsed.begin(); it != _asm_parsed.end(); it++)
                                                                                                ^
src/asm_parser.h:130:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = _asm_parsed.begin(); it != _asm_parsed.end(); it++)
                                                                                                ^
src/asm_parser.h:498:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                                ^
src/asm_parser.h:516:95: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                              ^
src/asm_parser.h:1500:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                                ^
src/asm_parser.h:1567:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                                ^
src/asm_parser.h:1608:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                                ^
src/asm_parser.h:1650:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      it2++;
      ^
src/asm_parser.h:1662:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                                ^
src/asm_parser.h:1734:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      it2++;
      ^
src/execute.h:886:104: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
            for (vector<Executable>::iterator it = _scExecutables.begin(); it != _scExecutables.end(); it++)
                                                                                                       ^
src/NodeToken.h:154:18: information: --check-library: Function displayStat() should have <noreturn> configuration [checkLibraryNoReturn]
    displayStat();
                 ^
src/execute_asm.h:502:21: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
    uint8_t third = scale8( offset8, (256 / 3)); // max = 85
                    ^
src/execute_asm.h:530:41: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
                    uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                                        ^
src/execute_asm.h:544:41: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
                    uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                                        ^
src/execute_asm.h:576:37: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
                uint8_t twothirds = scale8( offset8, ((256 * 2) / 3)); // max=170
                                    ^
src/execute_asm.h:613:22: information: --check-library: There is no matching configuration for function scale8_video_LEAVING_R1_DIRTY() [checkLibraryFunction]
    if( Gscale ) g = scale8_video_LEAVING_R1_DIRTY( g, Gscale);
                     ^
src/execute_asm.h:622:21: information: --check-library: There is no matching configuration for function scale8_video() [checkLibraryFunction]
            desat = scale8_video( desat, desat);
                    ^
src/execute_asm.h:634:25: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
            if( r ) r = scale8( r, satscale) + 1;
                        ^
src/execute_asm.h:635:25: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
            if( g ) g = scale8( g, satscale) + 1;
                        ^
src/execute_asm.h:636:25: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
            if( b ) b = scale8( b, satscale) + 1;
                        ^
src/execute_asm.h:648:15: information: --check-library: There is no matching configuration for function scale8_video_LEAVING_R1_DIRTY() [checkLibraryFunction]
        val = scale8_video_LEAVING_R1_DIRTY( val, val);
              ^
src/execute_asm.h:659:25: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
            if( r ) r = scale8( r, val) + 1;
                        ^
src/execute_asm.h:660:25: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
            if( g ) g = scale8( g, val) + 1;
                        ^
src/execute_asm.h:661:25: information: --check-library: There is no matching configuration for function scale8() [checkLibraryFunction]
            if( b ) b = scale8( b, val) + 1;
                        ^
src/execute_asm.h:672:12: information: --check-library: There is no matching configuration for function CRGB() [checkLibraryFunction]
    return CRGB(r,g,b);
           ^
src/execute_asm.h:517:35: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
                FORCE_REFERENCE(b);
                                  ^
src/execute_asm.h:525:39: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
                    FORCE_REFERENCE(b);
                                      ^
src/execute_asm.h:533:39: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
                    FORCE_REFERENCE(b);
                                      ^
src/execute_asm.h:548:39: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
                    FORCE_REFERENCE(b);
                                      ^
src/execute_asm.h:554:39: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
                    FORCE_REFERENCE(b);
                                      ^
src/execute_asm.h:685:70: information: --check-library: Function addExternalFunction() should have <noreturn> configuration [checkLibraryNoReturn]
        addExternalFunction("hsv", "CRGB","int,int,int", (void *)hsv);
                                                                     ^
src/execute.h:321:23: information: --check-library: There is no matching configuration for function createExectutable() [checkLibraryFunction]
        _executecmd = createExectutable(bin);
                      ^
src/execute.h:373:13: information: --check-library: There is no matching configuration for function freeExecutable() [checkLibraryFunction]
            freeExecutable(&_executecmd);
            ^
src/execute.h:540:13: information: --check-library: There is no matching configuration for function freeExecutable() [checkLibraryFunction]
            freeExecutable(&_executecmd);
            ^
src/execute.h:560:36: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        error_message_struct res = executeBinary("@_" + prog, _executecmd, 9999, this, args);
                                   ^
src/execute.h:572:36: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        error_message_struct res = executeBinary("@__footer", _executecmd, 9999, this, d);
                                   ^
src/execute.h:574:15: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
              ^
src/execute.h:591:36: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        error_message_struct res = executeBinary("@__footer", _executecmd, 9999, this, d);
                                   ^
src/execute.h:596:15: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        res = executeBinary("@__" + prog, _executecmd, 9999, this, args);
              ^
src/execute.h:665:36: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        error_message_struct res = executeBinary("@__footer", exec->df.exe, exec->__run_handle_index, exec, d);
                                   ^
src/execute.h:667:15: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        res = executeBinary(exec->df.args[0], exec->df.exe, exec->__run_handle_index, exec, exec->args);
              ^
src/execute.h:675:36: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        error_message_struct res = executeBinary("@__footer", exec->df.exe, exec->__run_handle_index, exec, d);
                                   ^
src/execute.h:676:15: information: --check-library: There is no matching configuration for function executeBinary() [checkLibraryFunction]
        res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec, exec->args);
              ^
src/ESPLiveScript.h:233:12: information: --check-library: There is no matching configuration for function createBinary() [checkLibraryFunction]
     bin = createBinary(&footer, &header, &content, __parser_debug);
           ^
src/ESPLiveScript.h:254:13: information: --check-library: There is no matching configuration for function freeBinary() [checkLibraryFunction]
            freeBinary(&bin);
            ^
src/ESPLiveScript.h:271:38: information: --check-library: There is no matching configuration for function createExectutable() [checkLibraryFunction]
            executable _executecmd = createExectutable(&bin);
                                     ^
src/NodeToken.h:23:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole(str, force);
          ^
src/ESPLiveScript.h:3562:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Something Already running kill it first ...");
                  ^
src/ESPLiveScript.h:3583:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(config.ENDLINE);
        ^
src/ESPLiveScript.h:3584:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
        ^
src/ESPLiveScript.h:3584:21: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
                    ^
src/ESPLiveScript.h:3626:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("Compiling ...", true);
              ^
src/ESPLiveScript.h:3633:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("filename missing ...", true);
              ^
src/ESPLiveScript.h:3654:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Something Already running kill it first ...");
                  ^
src/ESPLiveScript.h:3680:17: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
         Serial.printf("oioioioe");
                ^
src/ESPLiveScript.h:3694:27: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
                    LedOS.pushToConsole("***********START RUN *********");
                          ^
src/ESPLiveScript.h:3700:25: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
                        _push(config.ENDLINE);
                        ^
src/ESPLiveScript.h:3701:25: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
                        _push(cons->prompt(cons).c_str());
                        ^
src/ESPLiveScript.h:3701:37: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
                        _push(cons->prompt(cons).c_str());
                                    ^
src/ESPLiveScript.h:3706:27: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
                    LedOS.pushToConsole("Start program", true);
                          ^
src/ESPLiveScript.h:3709:27: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
                    LedOS.pushToConsole("Execution done.", true);
                          ^
src/ESPLiveScript.h:3716:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("filename missing ...", true);
              ^
src/ESPLiveScript.h:3723:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("Something Already running kill it first ...");
              ^
src/ESPLiveScript.h:3730:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole("Compiling ...", true);
          ^
src/ESPLiveScript.h:3749:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("***********START RUN *********");
                  ^
src/ESPLiveScript.h:3754:17: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
                _push(config.ENDLINE);
                ^
src/ESPLiveScript.h:3755:17: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
                _push(cons->prompt(cons).c_str());
                ^
src/ESPLiveScript.h:3755:29: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
                _push(cons->prompt(cons).c_str());
                            ^
src/ESPLiveScript.h:3760:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Start program", true);
                  ^
src/ESPLiveScript.h:3763:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Execution done.", true);
                  ^
src/ESPLiveScript.h:3768:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole(SCExecutable.error.error_message, true);
              ^
src/ESPLiveScript.h:3785:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(config.ENDLINE);
        ^
src/ESPLiveScript.h:3786:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
        ^
src/ESPLiveScript.h:3786:21: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
                    ^
src/ESPLiveScript.h:3801:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("compile", parse_c, "Compile and run a program add '&' for run on the second core");
              ^
src/ESPLiveScript.h:3802:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("comp", compile_c, "Compile  a program");
              ^
src/ESPLiveScript.h:3803:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("createbin", saveBin, "Compile  a program into binary");
              ^
src/ESPLiveScript.h:3804:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("executebin", binload, "executebin");
              ^
src/ESPLiveScript.h:3805:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("displaybin", displaybin, "displaybin");
              ^
src/ESPLiveScript.h:3806:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("./", binload, "executebin");
              ^
src/ESPLiveScript.h:3807:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("list", listExec, "list the compiled programs");
              ^
src/ESPLiveScript.h:3808:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("free", free, "free the binary free x will free the program with handle x");
              ^
src/ESPLiveScript.h:3809:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("run", run, "Run an already compiled program (always second Core) run x run program with handle x");
              ^
src/ESPLiveScript.h:3810:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("kill", kill, "Stop a running program kill x kill program with handle x");
              ^
src/ESPLiveScript.h:3811:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("parseasm", parseasm, "Parse assembly program");
              ^
src/ESPLiveScript.h:3812:15: information: --check-library: There is no matching configuration for function LedOS::addEscCommand() [checkLibraryFunction]
        LedOS.addEscCommand(18, parsec_cEsc, "Compile and execute a program (always second Core)");
              ^
src/ESPLiveScript.h:3813:15: information: --check-library: There is no matching configuration for function LedOS::addEscCommand() [checkLibraryFunction]
        LedOS.addEscCommand(11, kill_cEsc, "Stop a running program");
              ^
src/ESPLiveScript.h:4001:15: information: --check-library: There is no matching configuration for function LedOS::addHightLightinf() [checkLibraryFunction]
        LedOS.addHightLightinf("sc", formatLine, formatInit, formatLine);
              ^
src/ESPLiveScript.h:3505:65: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole("Nothing is currently running.", true);
                                                                ^
src/ESPLiveScript.h:3563:29: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
            kill(cons, args);
                            ^
src/ESPLiveScript.h:3584:42: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
        _push(cons->prompt(cons).c_str());
                                         ^
src/ESPLiveScript.h:3599:116: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        pushToConsole(string_format("Compiling done. Handle number:%d", scriptRuntime._scExecutables.size()), true);
                                                                                                                   ^
src/ESPLiveScript.h:3603:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        pushToConsole(_scExec.error.error_message);
                                                  ^
src/ESPLiveScript.h:3630:25: information: --check-library: Function freeBinary() should have <noreturn> configuration [checkLibraryNoReturn]
        freeBinary(&bin);
                        ^
src/ESPLiveScript.h:3642:25: information: --check-library: Function freeBinary() should have <noreturn> configuration [checkLibraryNoReturn]
        freeBinary(&bin);
                        ^
src/ESPLiveScript.h:3656:26: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
            kill(cons, k);
                         ^
src/ESPLiveScript.h:3682:73: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole(_executecmd.error.error_message.c_str(), true);
                                                                        ^
src/ESPLiveScript.h:3701:58: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
                        _push(cons->prompt(cons).c_str());
                                                         ^
src/ESPLiveScript.h:3725:22: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
        kill(cons, k);
                     ^
src/ESPLiveScript.h:3755:50: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
                _push(cons->prompt(cons).c_str());
                                                 ^
src/ESPLiveScript.h:3786:42: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
        _push(cons->prompt(cons).c_str());
                                         ^
src/NodeToken.h:1555:16: style: Local variable 'p' shadows outer variable [shadowVariable]
    NodeToken *p = current_node;
               ^
src/ESPLiveScript.h:3492:8: note: Shadowed declaration
Parser p = Parser();
       ^
src/NodeToken.h:1555:16: note: Shadow variable
    NodeToken *p = current_node;
               ^
src/NodeToken.h:4871:40: style: Local variable 'p' shadows outer variable [shadowVariable]
                        vector<string> p = split(d[1], ",");
                                       ^
src/ESPLiveScript.h:3492:8: note: Shadowed declaration
Parser p = Parser();
       ^
src/NodeToken.h:4871:40: note: Shadow variable
                        vector<string> p = split(d[1], ",");
                                       ^
src/ESPLiveScript.h:3514:33: performance: Function parameter 'variables' should be passed by const reference. [passedByValue]
Arguments parseInputArgs(string variables)
                                ^
src/ESPLiveScript.h:3587:45: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void parseasm(Console *cons, vector<string> args)
                                            ^
src/ESPLiveScript.h:3590:46: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void compile_c(Console *cons, vector<string> args)
                                             ^
src/ESPLiveScript.h:3790:45: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void listExec(Console *cons, vector<string> args)
                                            ^
src/ESPLiveScript.h:3666:13: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
            pushToConsole(bin.error.error_message.c_str(), true);
            ^
src/ESPLiveScript.h:3682:13: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
            pushToConsole(_executecmd.error.error_message.c_str(), true);
            ^
src/ESPLiveScript.h:329:16: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            sc = sc + "\n" + s;
               ^
src/ESPLiveScript.h:343:16: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            sc = sc + "\n" + s;
               ^
src/ESPLiveScript.h:3633:58: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        LedOS.pushToConsole("filename missing ...", true);
                                                         ^
src/ESPLiveScript.h:3716:58: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        LedOS.pushToConsole("filename missing ...", true);
                                                         ^
src/ESPLiveScript.h:3658:24: style: Variable 'othercore' is assigned a value that is never used. [unreadVariable]
        bool othercore = false;
                       ^
src/asm_struct_enum.h:252:17: style: Condition '!isReused(0)' is always true [knownConditionTrueFalse]
            if (!isReused(0))
                ^
src/asm_struct_enum.h:113:8: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
       for (int i =  _texts.size()-1; i >=0; i--)
       ^
src/asm_struct_enum.h:405:9: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
        if (pos < 0 or pos >= _texts.size())
        ^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

