src/NodeToken.h:4055:29: error: Using object that points to local variable '__f' that is out of scope. [invalidLifetime]
                        c = __num & 0xff;
                            ^
src/NodeToken.h:4046:58: note: Address of variable taken here.
                        __num = (uint32_t)(*((uint32_t *)&__f));
                                                         ^
src/NodeToken.h:4044:31: note: Variable created here.
                        float __f = 0;
                              ^
src/NodeToken.h:4055:29: note: Using object that points to local variable '__f' that is out of scope.
                        c = __num & 0xff;
                            ^
src/NodeToken.h:4058:33: error: Using object that points to local variable '__f' that is out of scope. [invalidLifetime]
                        __num = __num / 256;
                                ^
src/NodeToken.h:4046:58: note: Address of variable taken here.
                        __num = (uint32_t)(*((uint32_t *)&__f));
                                                         ^
src/NodeToken.h:4044:31: note: Variable created here.
                        float __f = 0;
                              ^
src/NodeToken.h:4058:33: note: Using object that points to local variable '__f' that is out of scope.
                        __num = __num / 256;
                                ^
src/string_function.h:40:35: information: --check-library: There is no matching configuration for function std::runtime_error() [checkLibraryFunction]
    if( size_s <= 0 ){ throw std::runtime_error( "Error during formatting." ); }
                                  ^
src/string_function.h:44:17: information: --check-library: There is no matching configuration for function std::string() [checkLibraryFunction]
    return std::string( buf.get(), buf.get() + size - 1 ); // We don't want the '\0' inside
                ^
src/asm_struct_enum.h:223:33: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
            _it = _texts.insert(next(_it), m);
                                ^
src/asm_struct_enum.h:230:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            return string(_texts.back());
                   ^
src/asm_struct_enum.h:236:16: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        return string(*_it);
               ^
src/asm_struct_enum.h:240:19: information: --check-library: There is no matching configuration for function findText() [checkLibraryFunction]
        int pos = findText(" ");
                  ^
src/asm_struct_enum.h:257:20: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            return string(_texts.front());
                   ^
src/asm_struct_enum.h:265:16: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        return string(_texts[pos]);
               ^
src/asm_struct_enum.h:285:27: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            if (s.compare(string(*_it)) == 0)
                          ^
src/tokenizer.h:781:17: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
            if (next(it) == script.end())
                ^
src/tokenizer.h:789:22: information: --check-library: There is no matching configuration for function next() [checkLibraryFunction]
                it = next(it);
                     ^
src/NodeToken.h:23:12: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
    Serial.printf("%s\r\n", str.c_str());
           ^
src/NodeToken.h:109:38: information: --check-library: There is no matching configuration for function uxTaskGetStackHighWaterMark() [checkLibraryFunction]
    UBaseType_t stackHighWaterMark = uxTaskGetStackHighWaterMark(loopTaskHandle);
                                     ^
src/NodeToken.h:134:38: information: --check-library: There is no matching configuration for function uxTaskGetStackHighWaterMark() [checkLibraryFunction]
    UBaseType_t stackHighWaterMark = uxTaskGetStackHighWaterMark(loopTaskHandle);
                                     ^
src/NodeToken.h:726:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                if (string(getTargetText()).compare(0, 1, "@") == 0)
                    ^
src/NodeToken.h:730:25: information: --check-library: There is no matching configuration for function findMember() [checkLibraryFunction]
                int i = findMember(_vartype, string(getTargetText()));
                        ^
src/NodeToken.h:730:46: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                int i = findMember(_vartype, string(getTargetText()));
                                             ^
src/NodeToken.h:769:45: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                int cmp = getChildAtPos(2)->getChildAtPos(i)->findMaxArgumentSize();
                                            ^
src/NodeToken.h:1557:15: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        res = string(p->getTargetText());
              ^
src/NodeToken.h:1708:18: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        else if (string(nd->getTokenText()).find("x") != string::npos)
                 ^
src/NodeToken.h:2204:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string sd = string(nd->getTargetText());
                    ^
src/NodeToken.h:2573:89: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            variables = string_format("%s %d", variables.c_str(), nd->getChildAtPos(1)->getChildAtPos(i)->getVarType()->total_size);
                                                                                        ^
src/NodeToken.h:2748:30: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            content.addAfter(string(_div[i]));
                             ^
src/NodeToken.h:2989:23: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    nd->setTargetText(string(nd->parent->getTargetText()));
                      ^
src/NodeToken.h:3232:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            if (nd->getChildAtPos(0)->getChildAtPos(j)->findMaxArgumentSize() - 1 >= i)
                                      ^
src/NodeToken.h:3258:34: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
        if (t->getChildAtPos(0)->getChildAtPos(i)->isPointer)
                                 ^
src/NodeToken.h:3261:35: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                                  ^
src/NodeToken.h:3277:45: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                if (func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType == __Args__)
                                            ^
src/NodeToken.h:3281:57: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                globalType.push(func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType);
                                                        ^
src/NodeToken.h:3282:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                                      ^
src/NodeToken.h:3289:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                                      ^
src/NodeToken.h:3292:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            if (nd->getChildAtPos(0)->getChildAtPos(i)->getVarType() != NULL and convert)
                                      ^
src/NodeToken.h:3293:71: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                translateType(globalType.get(), nd->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType, register_numl.get());
                                                                      ^
src/NodeToken.h:3299:52: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                _vartype = func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType;
                                                   ^
src/NodeToken.h:3302:53: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    _vartype = t->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType;
                                                    ^
src/NodeToken.h:3316:49: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                _vartype = t->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType;
                                                ^
src/NodeToken.h:3340:42: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                if (t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->_nodetype == numberNode)
                                         ^
src/NodeToken.h:3364:62: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    for (int k = 0; k < t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->getVarType()->size; k++)
                                                             ^
src/NodeToken.h:3371:46: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    if (t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->_nodetype == callFunctionNode)
                                             ^
src/NodeToken.h:3383:46: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    if (t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->_nodetype == extCallFunctionNode)
                                             ^
src/NodeToken.h:3395:51: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    else if (t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->_nodetype == localVariableNode)
                                                  ^
src/NodeToken.h:3399:138: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                            bufferText->addAfter(bufferText->sp.pop(), string_format("l32i a%d,a1,%d", regbase + i, t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->stack_pos));
                                                                                                                                         ^
src/NodeToken.h:3404:138: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                            bufferText->addAfter(bufferText->sp.pop(), string_format("l32i a%d,a1,%d", regbase + i, t->getChildAtPos(0)->getChildAtPos(i)->getChildAtPos(0)->stack_pos));
                                                                                                                                         ^
src/NodeToken.h:3407:51: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    else if (t->getChildAtPos(2)->getChildAtPos(i)->getChildAtPos(0)->_nodetype == globalVariableNode)
                                                  ^
src/NodeToken.h:3457:49: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    v = func->getChildAtPos(1)->getChildAtPos(i)->getVarType();
                                                ^
src/NodeToken.h:3459:47: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    v = nd->getChildAtPos(0)->getChildAtPos(i)->getVarType();
                                              ^
src/NodeToken.h:3516:41: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            if (func->getChildAtPos(1)->getChildAtPos(i)->isPointer)
                                        ^
src/NodeToken.h:3521:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                                      ^
src/NodeToken.h:3523:53: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                int start = func->getChildAtPos(1)->getChildAtPos(i)->stack_pos - _STACK_SIZE;
                                                    ^
src/NodeToken.h:3547:57: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                globalType.push(func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->_varType);
                                                        ^
src/NodeToken.h:3550:39: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                nd->getChildAtPos(0)->getChildAtPos(i)->visitNode();
                                      ^
src/NodeToken.h:3553:53: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                int start = func->getChildAtPos(1)->getChildAtPos(i)->stack_pos - _STACK_SIZE + func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->total_size;
                                                    ^
src/NodeToken.h:3554:51: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                int tot = func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size - 1;
                                                  ^
src/NodeToken.h:3555:61: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                for (int j = 0; j < func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size; j++)
                                                            ^
src/NodeToken.h:3558:47: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    if (nd->getChildAtPos(0)->getChildAtPos(i)->getVarType() != NULL)
                                              ^
src/NodeToken.h:3560:79: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                        translateType(globalType.get(), nd->getChildAtPos(0)->getChildAtPos(i)->getVarType()->_varType, register_numl.get());
                                                                              ^
src/NodeToken.h:3569:54: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    start -= func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->sizes[tot - j];
                                                     ^
src/NodeToken.h:3570:71: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                    asmInstruction asmInstr = func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->store[tot - j];
                                                                      ^
src/NodeToken.h:3578:58: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                        if (j == func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size - 1)
                                                         ^
src/NodeToken.h:3590:58: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
                        if (j == func->getChildAtPos(1)->getChildAtPos(i)->getVarType()->size - 1)
                                                         ^
src/NodeToken.h:3743:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                string sd = string(nd->getTargetText());
                            ^
src/NodeToken.h:4025:26: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            string str = string(nd->getChildAtPos(0)->getTokenText());
                         ^
src/NodeToken.h:4222:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string sd = string(nd->getTargetText());
                    ^
src/NodeToken.h:4400:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string sd = string(nd->getTargetText());
                    ^
src/NodeToken.h:4657:21: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    string target = string(nd->getTokenText());
                    ^
src/NodeToken.h:4715:26: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            string tmp = string((*text->getChildAtPos(i)));
                         ^
src/NodeToken.h:4778:26: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            string tmp = string((*text->getChildAtPos(i)));
                         ^
src/NodeToken.h:4823:26: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
            string tmp = string((*text->getChildAtPos(i)));
                         ^
src/asm_parser.h:502:16: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      if (trim(string((*it)->getText())).compare(trim(s)) == 0)
               ^
src/asm_parser.h:544:19: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    if (findLabel(string(res.getText()), asm_parsed) != -1)
                  ^
src/asm_parser.h:1037:27: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    int index = findLabel(string(ps.getText()), asm_parsed);
                          ^
src/asm_parser.h:1063:27: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
    int index = findLabel(string(ps.getText()), asm_parsed);
                          ^
src/asm_parser.h:1563:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLabel(string(parse_line->getText()), asm_parsed);
                            ^
src/asm_parser.h:1732:40: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      vector<string> args = split(trim(string((*it2)->getText())), " ");
                                       ^
src/asm_parser.h:1737:29: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLabel(string((*it)->getText()), asm_parsed);
                            ^
src/asm_parser.h:1743:30: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
        string stackstring = string((*it)->getText()).insert(2, "stack_");
                             ^
src/asm_parser.h:1804:28: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLink(string(textptr).substr(6, 100), externalType::value);
                           ^
src/asm_parser.h:1835:28: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      int index = findLink(string(textptr).substr(2, 100), externalType::function);
                           ^
src/asm_parser.h:1879:17: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      gc.name = string(textptr);
                ^
src/asm_parser.h:1884:22: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
      gc.variables = string(textptr);
                     ^
src/asm_parser.h:1918:32: information: --check-library: There is no matching configuration for function heap_caps_malloc() [checkLibraryFunction]
  uint32_t *exec = (uint32_t *)heap_caps_malloc(bin->instruction_size, MALLOC_CAP_EXEC);
                               ^
src/asm_parser.h:2045:18: information: --check-library: There is no matching configuration for function fs::FS::open() [checkLibraryFunction]
  File root = fs.open(name, FILE_WRITE);
                 ^
src/asm_parser.h:2046:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)"ESPLiveScript1.0.1", 19);
       ^
src/asm_parser.h:2047:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->tmp_instruction_size, 2);
       ^
src/asm_parser.h:2050:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->instruction_size, 2);
       ^
src/asm_parser.h:2053:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->data_size, 2);
       ^
src/asm_parser.h:2056:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write((uint8_t *)&bin->function_size, 2);
       ^
src/asm_parser.h:2059:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write(bin->binary_data, bin->tmp_instruction_size);
       ^
src/asm_parser.h:2060:8: information: --check-library: There is no matching configuration for function File::write() [checkLibraryFunction]
  root.write(bin->function_data, bin->function_size);
       ^
src/asm_parser.h:2095:18: information: --check-library: There is no matching configuration for function fs::FS::open() [checkLibraryFunction]
  File root = fs.open(name);
                 ^
src/asm_parser.h:2098:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)ver, 19);
       ^
src/asm_parser.h:2106:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->tmp_instruction_size, 2);
       ^
src/asm_parser.h:2109:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->instruction_size, 2);
       ^
src/asm_parser.h:2112:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->data_size, 2);
       ^
src/asm_parser.h:2115:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read((uint8_t *)&bin->function_size, 2);
       ^
src/asm_parser.h:2120:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read(tmp, bin->tmp_instruction_size);
       ^
src/asm_parser.h:2123:8: information: --check-library: There is no matching configuration for function File::read() [checkLibraryFunction]
  root.read(tmp2, bin->function_size);
       ^
src/asm_parser.h:2231:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(ex->start_program);
    ^
src/asm_parser.h:2239:5: information: --check-library: There is no matching configuration for function heap_caps_free() [checkLibraryFunction]
    heap_caps_free(ex->data);
    ^
src/execute.h:71:5: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
    vTaskDelay(1);
    ^
src/execute.h:125:17: information: --check-library: There is no matching configuration for function vTaskSuspend() [checkLibraryFunction]
                vTaskSuspend(__run_handles[i]);
                ^
src/execute.h:137:17: information: --check-library: There is no matching configuration for function vTaskResume() [checkLibraryFunction]
                vTaskResume(__run_handles[i]);
                ^
src/execute.h:149:9: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
        xEventGroupSync(xCreatedEventGroup,
        ^
src/execute.h:153:9: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
        vTaskDelay(10);
        ^
src/execute.h:154:9: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
        xEventGroupSync(xCreatedEventGroup2,
        ^
src/execute.h:237:16: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
    uxReturn = xEventGroupSync(xCreatedEventGroup,
               ^
src/execute.h:248:13: information: --check-library: There is no matching configuration for function xEventGroupClearBits() [checkLibraryFunction]
            xEventGroupClearBits(xCreatedEventGroup, MASK);
            ^
src/execute.h:259:13: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
            xEventGroupSync(xCreatedEventGroup2,
            ^
src/execute.h:269:13: information: --check-library: There is no matching configuration for function xEventGroupClearBits() [checkLibraryFunction]
            xEventGroupClearBits(xCreatedEventGroup2, MASK);
            ^
src/execute.h:274:9: information: --check-library: There is no matching configuration for function xEventGroupSync() [checkLibraryFunction]
        xEventGroupSync(xCreatedEventGroup2,
        ^
src/execute.h:367:20: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
            Serial.printf("Something Already running kill it first ...\r\n");
                   ^
src/execute.h:393:20: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
            Serial.printf("Halting the program...\r\n");
                   ^
src/execute.h:398:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(10);
            ^
src/execute.h:401:17: information: --check-library: There is no matching configuration for function vTaskSuspend() [checkLibraryFunction]
                vTaskSuspend(*runningPrograms.getHandleByIndex(__run_handle_index));
                ^
src/execute.h:406:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(10);
            ^
src/execute.h:412:20: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
            Serial.printf("Program Halted.\r\n");
                   ^
src/execute.h:428:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(10);
            ^
src/execute.h:429:13: information: --check-library: There is no matching configuration for function vTaskResume() [checkLibraryFunction]
            vTaskResume(*runningPrograms.getHandleByIndex(__run_handle_index));
            ^
src/execute.h:443:20: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
            Serial.printf("Stopping the program...\r\n");
                   ^
src/execute.h:450:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(10);
            ^
src/execute.h:456:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(30);
            ^
src/execute.h:460:17: information: --check-library: There is no matching configuration for function vTaskDelete() [checkLibraryFunction]
                vTaskDelete(*runningPrograms.getHandleByIndex(__run_handle_index));
                ^
src/execute.h:464:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(30);
            ^
src/execute.h:471:20: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
            Serial.printf("Program stopped.\r\n");
                   ^
src/execute.h:473:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(10);
            ^
src/execute.h:514:13: information: --check-library: There is no matching configuration for function vTaskDelay() [checkLibraryFunction]
            vTaskDelay(20);
            ^
src/execute.h:529:24: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
                Serial.printf("too many programs at once\r\n");
                       ^
src/execute.h:537:13: information: --check-library: There is no matching configuration for function xTaskCreateUniversal() [checkLibraryFunction]
            xTaskCreateUniversal(_run_task, taskname.c_str(), 4096 * 2, this, 3, (TaskHandle_t *)runningPrograms.getHandleByIndex(__run_handle_index), core);
            ^
src/execute.h:542:20: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
            Serial.printf("Execution on going CTRL + k to stop\r\n");
                   ^
src/execute.h:550:20: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
            Serial.printf("Nothing to execute\r\n");
                   ^
src/execute.h:707:5: information: --check-library: There is no matching configuration for function vTaskDelete() [checkLibraryFunction]
    vTaskDelete(NULL);
    ^
src/ESPLiveScript.h:530:33: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                    string sd = string(current_node->getTargetText());
                                ^
src/ESPLiveScript.h:574:21: information: --check-library: There is no matching configuration for function findMember() [checkLibraryFunction]
                i = findMember(current_node->getVarType(), string(current()->getText()));
                    ^
src/ESPLiveScript.h:574:60: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                i = findMember(current_node->getVarType(), string(current()->getText()));
                                                           ^
src/ESPLiveScript.h:586:56: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                i = findMember(current_node->_vartype, string(current()->getText()));
                                                       ^
src/ESPLiveScript.h:631:24: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
            current()->addText(string_format("%s.%s", search_result->getVarType()->varName.c_str(), current()->getText()));
                       ^
src/ESPLiveScript.h:672:77: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            current_node->getChildAtPos(current_node->children_size() - 1)->getChildAtPos(0)->getChildAtPos(0)->copyChildren(_node_token_stack.back());
                                                                            ^
src/ESPLiveScript.h:697:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(inputArgumentsNode));
                                     ^
src/ESPLiveScript.h:891:66: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                    else if (external_links[i].signature.compare(string(sav_t.back().getText())) == 0)
                                                                 ^
src/ESPLiveScript.h:1012:50: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            if (search_result->getChildAtPos(1)->getChildAtPos(i)->_vartype == __Args__)
                                                 ^
src/ESPLiveScript.h:1049:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(current(), comparatorNode));
                                     ^
src/ESPLiveScript.h:1074:23: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node->addChild(NodeToken(statementNode));
                      ^
src/ESPLiveScript.h:1078:27: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node->addChild(NodeToken(current(), stringNode));
                          ^
src/ESPLiveScript.h:1094:31: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node->addChild(NodeToken(c, breakNode));
                              ^
src/ESPLiveScript.h:1117:31: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node->addChild(NodeToken(c, continueNode));
                              ^
src/ESPLiveScript.h:1133:31: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node->addChild(NodeToken(returnNode));
                              ^
src/ESPLiveScript.h:1139:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(returnNode));
                                             ^
src/ESPLiveScript.h:1225:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(assignementNode));
                                         ^
src/ESPLiveScript.h:1232:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(unitaryOpNode));
                                         ^
src/ESPLiveScript.h:1268:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(assignementNode));
                                         ^
src/ESPLiveScript.h:1349:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(binOpNode));
                                             ^
src/ESPLiveScript.h:1436:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(current(), elseNode, targetList.pop()));
                                         ^
src/ESPLiveScript.h:1488:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(&sav_t.back(), whileNode, targetList.get()));
                                             ^
src/ESPLiveScript.h:1562:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(current(), ifNode, targetList.get()));
                                             ^
src/ESPLiveScript.h:1634:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(current(), forNode, targetList.get()));
                                             ^
src/ESPLiveScript.h:1636:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(statementNode));
                                             ^
src/ESPLiveScript.h:1666:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(statementNode));
                                             ^
src/ESPLiveScript.h:1777:32: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                    current()->addText(string_format("%s._@%s()", nodeTokenList.get().getVarType()->varName.c_str(), nodeTokenList.get().getVarType()->varName.c_str()));
                               ^
src/ESPLiveScript.h:1817:35: information: --check-library: There is no matching configuration for function Context::findVariable() [checkLibraryFunction]
                    current_cntx->findVariable(nodeTokenList.get().getTokenText(), false);
                                  ^
src/ESPLiveScript.h:1828:32: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                    current()->addText(string_format("%s._@%s", search_result->getVarType()->varName.c_str(), current()->getText()));
                               ^
src/ESPLiveScript.h:1871:46: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                current_node = current_node->addChild(NodeToken(assignementNode));
                                             ^
src/ESPLiveScript.h:1979:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(current(), blockStatementNode));
                                     ^
src/ESPLiveScript.h:2018:38: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
        current_node = current_node->addChild(NodeToken(defInputArgumentsNode));
                                     ^
src/ESPLiveScript.h:2342:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(ternaryIfNode));
                                         ^
src/ESPLiveScript.h:2380:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(binOpNode));
                                         ^
src/ESPLiveScript.h:2427:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(binOpNode));
                                         ^
src/ESPLiveScript.h:2480:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(testNode));
                                         ^
src/ESPLiveScript.h:2544:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(binOpNode));
                                         ^
src/ESPLiveScript.h:2598:27: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node->addChild(NodeToken(current(), numberNode));
                          ^
src/ESPLiveScript.h:2626:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(unitaryOpNode));
                                         ^
src/ESPLiveScript.h:2651:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(current(), changeTypeNode));
                                         ^
src/ESPLiveScript.h:2790:24: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
            current()->addText(string_format("%s._@%s", current()->getText(), current()->getText()));
                       ^
src/ESPLiveScript.h:2796:77: information: --check-library: There is no matching configuration for function NodeToken::getChildAtPos() [checkLibraryFunction]
            current_node->getChildAtPos(current_node->children_size() - 1)->getChildAtPos(2)->getChildAtPos(0)->copyChildren(_node_token_stack.back());
                                                                            ^
src/ESPLiveScript.h:2824:42: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            current_node = current_node->addChild(NodeToken(current(), numberNode));
                                         ^
src/ESPLiveScript.h:2895:40: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
            program.addChildFront(nd)->addChild(NodeToken(current(), stringNode));
                                       ^
src/ESPLiveScript.h:3005:47: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                    sizestr = sizestr + " " + string(current()->getText());
                                              ^
src/ESPLiveScript.h:3023:51: information: --check-library: There is no matching configuration for function string() [checkLibraryFunction]
                        sizestr = sizestr + " " + string(current()->getText());
                                                  ^
src/ESPLiveScript.h:3139:40: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                            current()->addText(string_format("%s._@%s", usded.varName.c_str(), current()->getText()));
                                       ^
src/ESPLiveScript.h:3158:40: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                            current()->addText(string_format("%s.%s", usded.varName.c_str(), current()->getText()));
                                       ^
src/ESPLiveScript.h:3365:44: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                                current()->addText(string_format("%s._@%s()", current_node->getVarType()->varName.c_str(), current_node->getVarType()->varName.c_str()));
                                           ^
src/ESPLiveScript.h:3384:43: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                            current_node->addChild(NodeToken(current(), stringNode));
                                          ^
src/ESPLiveScript.h:3448:40: information: --check-library: There is no matching configuration for function Token::addText() [checkLibraryFunction]
                            current()->addText(string_format("%s._@%s", current_node->getVarType()->varName.c_str(), current()->getText()));
                                       ^
src/ESPLiveScript.h:3487:58: information: --check-library: There is no matching configuration for function NodeToken::addChild() [checkLibraryFunction]
                            current_node = current_node->addChild(NodeToken(assignementNode));
                                                         ^
src/asm_struct_enum.h:72:9: information: --check-library: There is no matching configuration for function push() [checkLibraryFunction]
        push(sav + 1);
        ^
src/asm_struct_enum.h:81:9: information: --check-library: There is no matching configuration for function push() [checkLibraryFunction]
        push(sav - 1);
        ^
src/asm_struct_enum.h:557:3: warning: Member variable 'result_parse_line::bincode' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:557:3: warning: Member variable 'result_parse_line::size' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:557:3: warning: Member variable 'result_parse_line::op' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:557:3: warning: Member variable 'result_parse_line::address' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:557:3: warning: Member variable 'result_parse_line::align' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/asm_struct_enum.h:557:3: warning: Member variable 'result_parse_line::line' is not initialized in the constructor. [uninitMemberVar]
  result_parse_line(){}
  ^
src/tokenizer.h:890:5: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
    Token()
    ^
src/tokenizer.h:899:5: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
    Token(tokenType h)
    ^
src/tokenizer.h:907:5: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
    Token(tokenType _type, int __vartype, int _line)
    ^
src/tokenizer.h:916:5: warning: Member variable 'Token::line' is not initialized in the constructor. [uninitMemberVar]
    Token(tokenType _type, int __vartype)
    ^
src/tokenizer.h:982:5: warning: Member variable 'Tokens::_script' is not initialized in the constructor. [uninitMemberVar]
    Tokens()
    ^
src/ESPLiveScript.h:34:5: warning: Member variable '_arguments::intval' is not initialized in the constructor. [uninitMemberVar]
    _arguments()
    ^
src/ESPLiveScript.h:34:5: warning: Member variable '_arguments::floatval' is not initialized in the constructor. [uninitMemberVar]
    _arguments()
    ^
src/ESPLiveScript.h:38:5: warning: Member variable '_arguments::floatval' is not initialized in the constructor. [uninitMemberVar]
    _arguments(int val)
    ^
src/ESPLiveScript.h:43:5: warning: Member variable '_arguments::intval' is not initialized in the constructor. [uninitMemberVar]
    _arguments(float val)
    ^
src/execute.h:79:5: warning: Member variable '_executablesClass::nb_concurrent_programs_current' is not initialized in the constructor. [uninitMemberVar]
    _executablesClass()
    ^
src/execute.h:297:5: warning: Member variable 'Executable::error' is not initialized in the constructor. [uninitMemberVar]
    Executable()
    ^
src/execute.h:297:5: warning: Member variable 'Executable::df' is not initialized in the constructor. [uninitMemberVar]
    Executable()
    ^
src/execute.h:306:5: warning: Member variable 'Executable::__run_handle_index' is not initialized in the constructor. [uninitMemberVar]
    Executable(executable _executable)
    ^
src/execute.h:306:5: warning: Member variable 'Executable::error' is not initialized in the constructor. [uninitMemberVar]
    Executable(executable _executable)
    ^
src/execute.h:306:5: warning: Member variable 'Executable::df' is not initialized in the constructor. [uninitMemberVar]
    Executable(executable _executable)
    ^
src/asm_struct_enum.h:18:5: warning:inconclusive: Member variable 'Stack < int >::_default' is not initialized in the constructor. [uninitMemberVar]
    Stack() {}
    ^
src/asm_struct_enum.h:18:5: warning:inconclusive: Member variable 'Stack < varTypeEnum >::_default' is not initialized in the constructor. [uninitMemberVar]
    Stack() {}
    ^
src/asm_struct_enum.h:21:9: performance: Variable '_default' is assigned in constructor body. Consider performing initialization in initialization list. [useInitializationList]
        _default = def;
        ^
src/asm_struct_enum.h:234:12: style:inconclusive: Technically the member function 'Text::current' can be const. [functionConst]
    string current()
           ^
src/asm_struct_enum.h:261:12: style:inconclusive: Technically the member function 'Text::textAt' can be const. [functionConst]
    string textAt(int pos)
           ^
src/asm_struct_enum.h:387:9: style:inconclusive: Technically the member function 'Text::size' can be const. [functionConst]
    int size()
        ^
src/asm_struct_enum.h:436:9: style:inconclusive: Technically the member function 'Text::get' can be const. [functionConst]
    int get()
        ^
src/tokenizer.h:796:10: style:inconclusive: Technically the member function 'Script::currentChar' can be const. [functionConst]
    char currentChar()
         ^
src/tokenizer.h:925:15: style:inconclusive: Technically the member function 'Token::getType' can be const. [functionConst]
    tokenType getType()
              ^
src/tokenizer.h:999:9: style:inconclusive: Technically the member function 'Tokens::size' can be const. [functionConst]
    int size()
        ^
src/NodeToken.h:750:14: style:inconclusive: Technically the member function 'NodeToken::getNodeTokenType' can be const. [functionConst]
    nodeType getNodeTokenType()
             ^
src/NodeToken.h:754:9: style:inconclusive: Technically the member function 'NodeToken::children_size' can be const. [functionConst]
    int children_size()
        ^
src/NodeToken.h:1056:10: performance:inconclusive: Technically the member function 'Context::addFunction' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void addFunction(NodeToken *nd)
         ^
src/NodeToken.h:1097:10: performance:inconclusive: Technically the member function 'Context::findCandidate' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool findCandidate(char *str)
         ^
src/NodeToken.h:1124:10: performance:inconclusive: Technically the member function 'Context::findFunction' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    void findFunction(Token *t)
         ^
src/ESPLiveScript.h:75:9: style:inconclusive: Technically the member function 'Arguments::size' can be const. [functionConst]
    int size()
        ^
src/execute.h:184:9: performance:inconclusive: Technically the member function '_executablesClass::getFirstHandle' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int getFirstHandle()
        ^
src/execute.h:577:10: style:inconclusive: Technically the member function 'Executable::isExeExists' can be const. [functionConst]
    bool isExeExists()
         ^
src/execute.h:661:10: style:inconclusive: Technically the member function 'Executable::isRunning' can be const. [functionConst]
    bool isRunning()
         ^
src/ESPLiveScript.h:142:9: performance:inconclusive: Technically the member function 'Parser::size' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    int size()
        ^
src/ESPLiveScript.h:166:10: performance:inconclusive: Technically the member function 'Parser::Match' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool Match(tokenType tt)
         ^
src/ESPLiveScript.h:170:10: performance:inconclusive: Technically the member function 'Parser::Match' can be static (but you may consider moving to unnamed namespace). [functionStatic]
    bool Match(tokenType tt, int index)
         ^
src/tokenizer.h:899:5: style: Class 'Token' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Token(tokenType h)
    ^
src/NodeToken.h:425:5: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    NodeToken(nodeType tt)
    ^
src/NodeToken.h:438:5: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    NodeToken(Token *t)
    ^
src/NodeToken.h:521:5: style: Class 'NodeToken' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    NodeToken(NodeToken *nd)
    ^
src/ESPLiveScript.h:38:5: style: Class '_arguments' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    _arguments(int val)
    ^
src/ESPLiveScript.h:43:5: style: Class '_arguments' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    _arguments(float val)
    ^
src/execute.h:306:5: style: Class 'Executable' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Executable(executable _executable)
    ^
src/asm_struct_enum.h:19:5: style: Class 'Stack < int >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Stack(T def)
    ^
src/asm_struct_enum.h:19:5: style: Class 'Stack < NodeToken >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Stack(T def)
    ^
src/asm_struct_enum.h:19:5: style: Class 'Stack < string >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Stack(T def)
    ^
src/asm_struct_enum.h:19:5: style: Class 'Stack < varTypeEnum >' has a constructor with 1 argument that is not explicit. [noExplicitConstructor]
    Stack(T def)
    ^
src/NodeToken.h:3217:11: style: Condition 't==NULL' is always false [knownConditionTrueFalse]
    if (t == NULL)
          ^
src/NodeToken.h:3200:12: note: Assuming that condition 'nd==NULL' is not redundant
    if (nd == NULL)
           ^
src/NodeToken.h:3216:20: note: Assignment 't=nd', assigned value is 0
    NodeToken *t = nd; // cntx.findFunction(nd->_token);
                   ^
src/NodeToken.h:3217:11: note: Condition 't==NULL' is always false
    if (t == NULL)
          ^
src/execute.h:447:20: style: Condition '!toResetSync' is always false [knownConditionTrueFalse]
            while (!toResetSync)
                   ^
src/execute.h:446:27: note: Assignment 'toResetSync=true', assigned value is 1
            toResetSync = true;
                          ^
src/execute.h:447:20: note: Condition '!toResetSync' is always false
            while (!toResetSync)
                   ^
src/NodeToken.h:4051:25: warning: %lu in format string (no. 1) requires 'unsigned long *' but the argument type is 'unsigned int *'. [invalidScanfArgType_int]
                        sscanf(ndt->getTokenText(), "%lu", &__num);
                        ^
src/execute.h:570:13: warning: %ld in format string (no. 1) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            printf("Free memory after:%ld freed:%ld\r\n", mema, mema - memb);
            ^
src/execute.h:570:13: warning: %ld in format string (no. 2) requires 'long' but the argument type is 'unsigned int'. [invalidPrintfArgType_sint]
            printf("Free memory after:%ld freed:%ld\r\n", mema, mema - memb);
            ^
src/asm_struct_enum.h:610:5: information: --check-library: Function push_back() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return parsed_lines.back();
    ^
src/tokenizer.h:1007:55: information: --check-library: Function tokenizer() should have <noreturn> configuration [checkLibraryNoReturn]
        tokenizer(script, true, increae_line, nbToken);
                                                      ^
src/tokenizer.h:1016:57: information: --check-library: Function tokenizer() should have <noreturn> configuration [checkLibraryNoReturn]
        tokenizer(script, update, increae_line, nbToken);
                                                        ^
src/NodeToken.h:32:30: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    pushToConsole(str, false);
                             ^
src/NodeToken.h:120:264: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    pushToConsole(string_format("max used memory: %ld maxstack:%ld  started %d free mem:%ld consumed %ld time:%dms", __maxMemUsage, __MaxStackMemory, __startmem, esp_get_free_heap_size(), __startmem - esp_get_free_heap_size(), (__endtime - __starttime) / 240000));
                                                                                                                                                                                                                                                                       ^
src/NodeToken.h:1958:64: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
        translateType(globalType.get(), r, register_numr.get());
                                                               ^
src/NodeToken.h:2423:82: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
                translateType(globalType.get(), v->_varType, register_numl.get());
                                                                                 ^
src/NodeToken.h:2772:111: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
            translateType(globalType.get(), nd->getChildAtPos(1)->getVarType()->_varType, register_numl.get());
                                                                                                              ^
src/NodeToken.h:3609:50: information: --check-library: Function _visitCallFunctionTemplate() should have <noreturn> configuration [checkLibraryNoReturn]
        _visitCallFunctionTemplate(nd, 10, false);
                                                 ^
src/NodeToken.h:3791:106: information: --check-library: Function translateType() should have <noreturn> configuration [checkLibraryNoReturn]
                translateType(__int__, nd->getChildAtPos(0)->getVarType()->_varType, register_numl.get());
                                                                                                         ^
src/asm_parser.h:1928:5: information: --check-library: Function decodeBinaryHeader() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return exe;
    ^
src/asm_parser.h:1936:5: information: --check-library: Function decodeBinaryHeader() should have <use>/<leak-ignore> configuration [checkLibraryUseIgnore]
    return exe;
    ^
src/asm_parser.h:2154:9: information: --check-library: Function asm() should have <noreturn> configuration [checkLibraryNoReturn]
      :);
        ^
src/asm_parser.h:2231:38: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(ex->start_program);
                                     ^
src/asm_parser.h:2239:29: information: --check-library: Function heap_caps_free() should have <noreturn> configuration [checkLibraryNoReturn]
    heap_caps_free(ex->data);
                            ^
src/execute.h:71:18: information: --check-library: Function vTaskDelay() should have <noreturn> configuration [checkLibraryNoReturn]
    vTaskDelay(1);
                 ^
src/execute.h:157:39: information: --check-library: Function xEventGroupSync() should have <noreturn> configuration [checkLibraryNoReturn]
                        portMAX_DELAY);
                                      ^
src/execute.h:206:27: information: --check-library: Function _prekill() should have <noreturn> configuration [checkLibraryNoReturn]
                _prekill();
                          ^
src/execute.h:214:28: information: --check-library: Function _postkill() should have <noreturn> configuration [checkLibraryNoReturn]
                _postkill();
                           ^
src/execute.h:269:60: information: --check-library: Function xEventGroupClearBits() should have <noreturn> configuration [checkLibraryNoReturn]
            xEventGroupClearBits(xCreatedEventGroup2, MASK);
                                                           ^
src/execute.h:277:39: information: --check-library: Function xEventGroupSync() should have <noreturn> configuration [checkLibraryNoReturn]
                        portMAX_DELAY);
                                      ^
src/execute.h:376:41: information: --check-library: Function freeExecutable() should have <noreturn> configuration [checkLibraryNoReturn]
            freeExecutable(&_executecmd);
                                        ^
src/execute.h:401:84: information: --check-library: Function vTaskSuspend() should have <noreturn> configuration [checkLibraryNoReturn]
                vTaskSuspend(*runningPrograms.getHandleByIndex(__run_handle_index));
                                                                                   ^
src/execute.h:590:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole(res.error_message, true);
                                                  ^
src/execute.h:602:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole(res.error_message, true);
                                                  ^
src/execute.h:690:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole(res.error_message, true);
                                                  ^
src/execute.h:699:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole(res.error_message, true);
                                                  ^
src/execute.h:707:22: information: --check-library: Function vTaskDelete() should have <noreturn> configuration [checkLibraryNoReturn]
    vTaskDelete(NULL);
                     ^
src/execute.h:755:71: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole("please add a name to the executable", true);
                                                                      ^
src/ESPLiveScript.h:319:77: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
                pushToConsole(_executecmd.error.error_message.c_str(), true);
                                                                            ^
src/ESPLiveScript.h:4057:89: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
    pushToConsole(string_format("Overflow error  max size: %d got %d", size, got), true);
                                                                                        ^
src/ESPLiveScript.h:4066:90: information: --check-library: Function addExternalFunction() should have <noreturn> configuration [checkLibraryNoReturn]
        addExternalFunction("error", "void", "int,uint32_t,uint32_t", (void *)&showError);
                                                                                         ^
src/asm_struct_enum.h:72:22: information: --check-library: Function push() should have <noreturn> configuration [checkLibraryNoReturn]
        push(sav + 1);
                     ^
src/asm_struct_enum.h:81:22: information: --check-library: Function push() should have <noreturn> configuration [checkLibraryNoReturn]
        push(sav - 1);
                     ^
src/NodeToken.h:1548:12: warning: Either the condition 'p!=NULL' is redundant or there is possible null pointer dereference: p. [nullPointerRedundantCheck]
    while (p->_nodetype != forNode and p->_nodetype != whileNode)
           ^
src/NodeToken.h:1554:11: note: Assuming that condition 'p!=NULL' is not redundant
    if (p != NULL)
          ^
src/NodeToken.h:1548:12: note: Null pointer dereference
    while (p->_nodetype != forNode and p->_nodetype != whileNode)
           ^
src/NodeToken.h:3196:26: warning: Either the condition 'nd==NULL' is redundant or there is possible null pointer dereference: nd. [nullPointerRedundantCheck]
    int staack_offset = (nd->getChildAtPos(0)->children_size() - 7) * 4;
                         ^
src/NodeToken.h:3200:12: note: Assuming that condition 'nd==NULL' is not redundant
    if (nd == NULL)
           ^
src/NodeToken.h:3196:26: note: Null pointer dereference
    int staack_offset = (nd->getChildAtPos(0)->children_size() - 7) * 4;
                         ^
src/NodeToken.h:3621:9: warning: Either the condition 'v==NULL' is redundant or there is possible null pointer dereference: v. [nullPointerRedundantCheck]
    if (v->size > 1)
        ^
src/NodeToken.h:3615:11: note: Assuming that condition 'v==NULL' is not redundant
    if (v == NULL)
          ^
src/NodeToken.h:3621:9: note: Null pointer dereference
    if (v->size > 1)
        ^
src/asm_struct_enum.h:607:28: style: C-style pointer casting [cstyleCast]
    result_parse_line *tmp=(result_parse_line *)malloc(sizeof(result_parse_line));
                           ^
src/asm_struct_enum.h:635:26: style: C-style pointer casting [cstyleCast]
  result_parse_line *tmp=(result_parse_line *)malloc(sizeof(result_parse_line));
                         ^
src/execute.h:677:25: style: C-style pointer casting [cstyleCast]
    Executable *exec = ((Executable *)pvParameters);
                        ^
src/NodeToken.h:1682:43: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
            uint32_t __num = (uint32_t)(*((uint32_t *)&__f));
                                          ^
src/NodeToken.h:4046:46: portability: Casting from float * to unsigned int * is not portable due to different binary data representations on different platforms. [invalidPointerCast]
                        __num = (uint32_t)(*((uint32_t *)&__f));
                                             ^
src/execute.h:599:15: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
          res = executeBinary("@__" + prog, _executecmd, 9999, this,args);
              ^
src/execute.h:598:34: note: res is initialized
        error_message_struct res = executeBinary("@__footer", _executecmd, 9999,this, args);
                                 ^
src/execute.h:599:15: note: res is overwritten
          res = executeBinary("@__" + prog, _executecmd, 9999, this,args);
              ^
src/execute.h:616:15: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
          res = executeBinary("@__" + prog, _executecmd, 9999,this,args);
              ^
src/execute.h:615:42: note: res is initialized
                error_message_struct res = executeBinary("@__footer", _executecmd, 9999, this,args);
                                         ^
src/execute.h:616:15: note: res is overwritten
          res = executeBinary("@__" + prog, _executecmd, 9999,this,args);
              ^
src/execute.h:687:14: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
         res = executeBinary(exec->df.args[0], exec->df.exe, exec->__run_handle_index, exec,exec->args);
             ^
src/execute.h:685:42: note: res is initialized
                error_message_struct res = executeBinary("@__footer",  exec->df.exe, exec->__run_handle_index, exec,d);
                                         ^
src/execute.h:687:14: note: res is overwritten
         res = executeBinary(exec->df.args[0], exec->df.exe, exec->__run_handle_index, exec,exec->args);
             ^
src/execute.h:696:14: style: Redundant initialization for 'res'. The initialized value is overwritten before it is read. [redundantInitialization]
         res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec,exec->args);
             ^
src/execute.h:695:35: note: res is initialized
         error_message_struct res = executeBinary("@__footer",  exec->df.exe, exec->__run_handle_index,exec, d);
                                  ^
src/execute.h:696:14: note: res is overwritten
         res = executeBinary("@__main", exec->df.exe, exec->__run_handle_index, exec,exec->args);
             ^
src/ESPLiveScript.h:180:22: style: Variable 'point_regnum' is reassigned a value before the old one has been used. [redundantAssignment]
        point_regnum = 4;
                     ^
src/ESPLiveScript.h:179:22: note: point_regnum is assigned
        point_regnum = 4;
                     ^
src/ESPLiveScript.h:180:22: note: point_regnum is overwritten
        point_regnum = 4;
                     ^
src/NodeToken.h:3207:9: style:inconclusive: Found duplicate branches for 'if' and 'else'. [duplicateBranch]
        if (isExtCall)
        ^
src/NodeToken.h:3209:9: note: Found duplicate branches for 'if' and 'else'.
        else
        ^
src/NodeToken.h:3207:9: note: Found duplicate branches for 'if' and 'else'.
        if (isExtCall)
        ^
src/NodeToken.h:4677:13: style:inconclusive: Found duplicate branches for 'if' and 'else'. [duplicateBranch]
            if (strlen(nd->getChildAtPos(i)->getTokenText()) > 0)
            ^
src/NodeToken.h:4679:13: note: Found duplicate branches for 'if' and 'else'.
            else
            ^
src/NodeToken.h:4677:13: note: Found duplicate branches for 'if' and 'else'.
            if (strlen(nd->getChildAtPos(i)->getTokenText()) > 0)
            ^
src/NodeToken.h:1524:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        break;
        ^
src/NodeToken.h:1639:9: style: Consecutive return, break, continue, goto or throw statements are unnecessary. [duplicateBreak]
        break;
        ^
src/NodeToken.h:3572:25: style: The scope of the variable 'sav' can be reduced. [variableScope]
                    int sav;
                        ^
src/NodeToken.h:3884:9: style: The scope of the variable 'sav' can be reduced. [variableScope]
    int sav = 9;
        ^
src/NodeToken.h:4037:21: style: The scope of the variable 'c' can be reduced. [variableScope]
            uint8_t c;
                    ^
src/NodeToken.h:4906:29: style: The scope of the variable 'ind' can be reduced. [variableScope]
                        int ind = -1;
                            ^
src/asm_parser.h:82:9: style: The scope of the variable 'add_size' can be reduced. [variableScope]
    int add_size = 0;
        ^
src/asm_parser.h:452:12: style: The scope of the variable 'values' can be reduced. [variableScope]
  uint32_t values[4];
           ^
src/asm_parser.h:2067:8: style: The scope of the variable 'ver' can be reduced. [variableScope]
  char ver[19];
       ^
src/ESPLiveScript.h:2994:17: style: The scope of the variable 'j' can be reduced. [variableScope]
            int j = 0;
                ^
src/execute.h:713:34: style:inconclusive: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'. [funcArgNamesDifferent]
void _executablesClass::kill(int handle_number)
                                 ^
src/execute.h:117:19: note: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'.
    void kill(int handle);
                  ^
src/execute.h:713:34: note: Function 'kill' argument 1 names different: declaration 'handle' definition 'handle_number'.
void _executablesClass::kill(int handle_number)
                                 ^
src/tokenizer.h:1961:18: style: Local variable 'c2' shadows outer variable [shadowVariable]
            char c2 = script->nextChar();
                 ^
src/tokenizer.h:1316:10: note: Shadowed declaration
    char c2;
         ^
src/tokenizer.h:1961:18: note: Shadow variable
            char c2 = script->nextChar();
                 ^
src/tokenizer.h:2140:26: style: Local variable 'c2' shadows outer variable [shadowVariable]
                    char c2 = script->nextChar();
                         ^
src/tokenizer.h:1316:10: note: Shadowed declaration
    char c2;
         ^
src/tokenizer.h:2140:26: note: Shadow variable
                    char c2 = script->nextChar();
                         ^
src/NodeToken.h:1058:20: style: Local variable '__tmpToken' shadows outer variable [shadowVariable]
        NodeToken *__tmpToken = new NodeToken();
                   ^
src/NodeToken.h:400:12: note: Shadowed declaration
NodeToken *__tmpToken;
           ^
src/NodeToken.h:1058:20: note: Shadow variable
        NodeToken *__tmpToken = new NodeToken();
                   ^
src/NodeToken.h:2477:13: style: Local variable 'start' shadows outer variable [shadowVariable]
        int start = nd->stack_pos;
            ^
src/NodeToken.h:2464:9: note: Shadowed declaration
    int start = nd->stack_pos;
        ^
src/NodeToken.h:2477:13: note: Shadow variable
        int start = nd->stack_pos;
            ^
src/NodeToken.h:3896:21: style: Local variable 'start' shadows outer variable [shadowVariable]
                int start = nd->getChildAtPos(i)->stack_pos;
                    ^
src/NodeToken.h:3892:17: note: Shadowed declaration
            int start = nd->getChildAtPos(i)->stack_pos;
                ^
src/NodeToken.h:3896:21: note: Shadow variable
                int start = nd->getChildAtPos(i)->stack_pos;
                    ^
src/NodeToken.h:4907:30: style: Local variable 'found' shadows outer variable [shadowVariable]
                        bool found = false;
                             ^
src/NodeToken.h:60:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:4907:30: note: Shadow variable
                        bool found = false;
                             ^
src/NodeToken.h:4950:30: style: Local variable 'found' shadows outer variable [shadowVariable]
                        bool found = false;
                             ^
src/NodeToken.h:60:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:4950:30: note: Shadow variable
                        bool found = false;
                             ^
src/NodeToken.h:5046:30: style: Local variable 'found' shadows outer variable [shadowVariable]
                        bool found = false;
                             ^
src/NodeToken.h:60:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5046:30: note: Shadow variable
                        bool found = false;
                             ^
src/NodeToken.h:5100:30: style: Local variable 'found' shadows outer variable [shadowVariable]
                        bool found = false;
                             ^
src/NodeToken.h:60:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5100:30: note: Shadow variable
                        bool found = false;
                             ^
src/NodeToken.h:5154:30: style: Local variable 'found' shadows outer variable [shadowVariable]
                        bool found = false;
                             ^
src/NodeToken.h:60:6: note: Shadowed declaration
bool found;
     ^
src/NodeToken.h:5154:30: note: Shadow variable
                        bool found = false;
                             ^
src/asm_parser.h:1287:22: style: Local variable '__v' shadows outer variable [shadowVariable]
      vector<string> __v = split(trim(str), " ");
                     ^
src/tokenizer.h:80:9: note: Shadowed declaration
varType __v;
        ^
src/asm_parser.h:1287:22: note: Shadow variable
      vector<string> __v = split(trim(str), " ");
                     ^
src/asm_parser.h:1790:16: style: Local variable 'content' shadows outer variable [shadowVariable]
      uint32_t content = bincode + address;
               ^
src/NodeToken.h:346:6: note: Shadowed declaration
Text content;
     ^
src/asm_parser.h:1790:16: note: Shadow variable
      uint32_t content = bincode + address;
               ^
src/asm_parser.h:1808:18: style: Local variable 'content' shadows outer variable [shadowVariable]
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/NodeToken.h:346:6: note: Shadowed declaration
Text content;
     ^
src/asm_parser.h:1808:18: note: Shadow variable
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/asm_parser.h:1845:18: style: Local variable 'content' shadows outer variable [shadowVariable]
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/NodeToken.h:346:6: note: Shadowed declaration
Text content;
     ^
src/asm_parser.h:1845:18: note: Shadow variable
        uint32_t content = (uint32_t)((external_links[index].ptr));
                 ^
src/asm_parser.h:2189:18: style: Local variable 'i' shadows outer variable [shadowVariable]
        for (int i = 1; i < args.size(); i++)
                 ^
src/asm_parser.h:2163:12: note: Shadowed declaration
  for (int i = 0; i < ex.functions.size(); i++)
           ^
src/asm_parser.h:2189:18: note: Shadow variable
        for (int i = 1; i < args.size(); i++)
                 ^
src/ESPLiveScript.h:407:30: style: Local variable 'i' shadows outer variable [shadowVariable]
                    for (int i = 0; i < __DEPTH; i++)
                             ^
src/ESPLiveScript.h:391:22: note: Shadowed declaration
            for (int i = 0; i < external_links.size(); i++)
                     ^
src/ESPLiveScript.h:407:30: note: Shadow variable
                    for (int i = 0; i < __DEPTH; i++)
                             ^
src/ESPLiveScript.h:508:30: style: Local variable 'nd' shadows outer variable [shadowVariable]
                   NodeToken nd = NodeToken(changeTypeNode);
                             ^
src/ESPLiveScript.h:477:22: note: Shadowed declaration
           NodeToken nd = NodeToken(changeTypeNode);
                     ^
src/ESPLiveScript.h:508:30: note: Shadow variable
                   NodeToken nd = NodeToken(changeTypeNode);
                             ^
src/ESPLiveScript.h:764:20: style: Local variable '_signature' shadows outer variable [shadowVariable]
            string _signature = sigs.back() + "*";
                   ^
src/ESPLiveScript.h:758:16: note: Shadowed declaration
        string _signature = sigs.back() + current_node->getVarType()->varName;
               ^
src/ESPLiveScript.h:764:20: note: Shadow variable
            string _signature = sigs.back() + "*";
                   ^
src/ESPLiveScript.h:779:22: style: Local variable 'nd' shadows outer variable [shadowVariable]
           NodeToken nd =NodeToken(changeTypeNode);
                     ^
src/ESPLiveScript.h:745:19: note: Shadowed declaration
        NodeToken nd = NodeToken(changeTypeNode);
                  ^
src/ESPLiveScript.h:779:22: note: Shadow variable
           NodeToken nd =NodeToken(changeTypeNode);
                     ^
src/ESPLiveScript.h:791:20: style: Local variable '_signature' shadows outer variable [shadowVariable]
            string _signature = sigs.back() + "|" + current_node->getVarType()->varName;
                   ^
src/ESPLiveScript.h:758:16: note: Shadowed declaration
        string _signature = sigs.back() + current_node->getVarType()->varName;
               ^
src/ESPLiveScript.h:791:20: note: Shadow variable
            string _signature = sigs.back() + "|" + current_node->getVarType()->varName;
                   ^
src/ESPLiveScript.h:797:24: style: Local variable '_signature' shadows outer variable [shadowVariable]
                string _signature = sigs.back() + "*";
                       ^
src/ESPLiveScript.h:791:20: note: Shadowed declaration
            string _signature = sigs.back() + "|" + current_node->getVarType()->varName;
                   ^
src/ESPLiveScript.h:797:24: note: Shadow variable
                string _signature = sigs.back() + "*";
                       ^
src/ESPLiveScript.h:2097:23: style: Local variable '_nd' shadows outer variable [shadowVariable]
            NodeToken _nd = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:2055:19: note: Shadowed declaration
        NodeToken _nd = nodeTokenList.pop();
                  ^
src/ESPLiveScript.h:2097:23: note: Shadow variable
            NodeToken _nd = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:2099:23: style: Local variable '_t' shadows outer variable [shadowVariable]
            NodeToken _t = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:2057:19: note: Shadowed declaration
        NodeToken _t = nodeTokenList.pop();
                  ^
src/ESPLiveScript.h:2099:23: note: Shadow variable
            NodeToken _t = nodeTokenList.pop();
                      ^
src/ESPLiveScript.h:3212:43: style: Local variable 'nd' shadows outer variable [shadowVariable]
                                NodeToken nd = NodeToken(current(), defLocalVariableNode);
                                          ^
src/ESPLiveScript.h:3183:39: note: Shadowed declaration
                            NodeToken nd = NodeToken(current(), defLocalVariableNode);
                                      ^
src/ESPLiveScript.h:3212:43: note: Shadow variable
                                NodeToken nd = NodeToken(current(), defLocalVariableNode);
                                          ^
src/ESPLiveScript.h:3327:43: style: Local variable 'nd' shadows outer variable [shadowVariable]
                                NodeToken nd = nodeTokenList.pop();
                                          ^
src/ESPLiveScript.h:3298:35: note: Shadowed declaration
                        NodeToken nd = nodeTokenList.pop();
                                  ^
src/ESPLiveScript.h:3327:43: note: Shadow variable
                                NodeToken nd = nodeTokenList.pop();
                                          ^
src/ESPLiveScript.h:3328:43: style: Local variable '_t' shadows outer variable [shadowVariable]
                                NodeToken _t = nodeTokenList.pop();
                                          ^
src/ESPLiveScript.h:3299:35: note: Shadowed declaration
                        NodeToken _t = nodeTokenList.pop();
                                  ^
src/ESPLiveScript.h:3328:43: note: Shadow variable
                                NodeToken _t = nodeTokenList.pop();
                                          ^
src/ESPLiveScript.h:3449:39: style: Local variable 'nd' shadows outer variable [shadowVariable]
                            NodeToken nd = NodeToken(*current_node);
                                      ^
src/ESPLiveScript.h:3298:35: note: Shadowed declaration
                        NodeToken nd = nodeTokenList.pop();
                                  ^
src/ESPLiveScript.h:3449:39: note: Shadow variable
                            NodeToken nd = NodeToken(*current_node);
                                      ^
src/ESPLiveScript.h:3484:39: style: Local variable 'nd' shadows outer variable [shadowVariable]
                            NodeToken nd = NodeToken(*current_node);
                                      ^
src/ESPLiveScript.h:3298:35: note: Shadowed declaration
                        NodeToken nd = nodeTokenList.pop();
                                  ^
src/ESPLiveScript.h:3484:39: note: Shadow variable
                            NodeToken nd = NodeToken(*current_node);
                                      ^
src/asm_struct_enum.h:150:35: performance: Function parameter 's' should be passed by const reference. [passedByValue]
    void addAfter(int pos, string s)
                                  ^
src/asm_struct_enum.h:162:36: performance: Function parameter 's' should be passed by const reference. [passedByValue]
    void addBefore(int pos, string s)
                                   ^
src/tokenizer.h:563:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalDefine(string name,string content)
                              ^
src/tokenizer.h:563:43: performance: Function parameter 'content' should be passed by const reference. [passedByValue]
void addExternalDefine(string name,string content)
                                          ^
src/tokenizer.h:1159:25: performance: Function parameter 't' should be passed by const reference. [passedByValue]
void displaytoken(token t)
                        ^
src/asm_external.h:24:33: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalFunction(string name,string out,string in, void * ptr)
                                ^
src/asm_external.h:24:56: performance: Function parameter 'in' should be passed by const reference. [passedByValue]
void addExternalFunction(string name,string out,string in, void * ptr)
                                                       ^
src/asm_external.h:66:33: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out,string in,void * ptr)
                                ^
src/asm_external.h:66:46: performance: Function parameter 'out' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out,string in,void * ptr)
                                             ^
src/asm_external.h:66:57: performance: Function parameter 'in' should be passed by const reference. [passedByValue]
void addExternalVariable(string name, string out,string in,void * ptr)
                                                        ^
src/asm_external.h:77:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
void addExternal(string name, externalType type, void * ptr)
                        ^
src/NodeToken.h:30:27: performance: Function parameter 'str' should be passed by const reference. [passedByValue]
void pushToConsole(string str)
                          ^
src/NodeToken.h:535:22: performance: Function parameter '_target' should be passed by const reference. [passedByValue]
    NodeToken(string _target, nodeType tt)
                     ^
src/NodeToken.h:541:49: performance: Function parameter '_target' should be passed by const reference. [passedByValue]
    NodeToken(NodeToken nd, nodeType tt, string _target)
                                                ^
src/asm_parser.h:448:41: performance: Function parameter 'str' should be passed by const reference. [passedByValue]
result_parse_line parseOperandes(string str, int nboperande, operandeType *optypes, int size, uint32_t (*createbin)(uint32_t *val))
                                        ^
src/asm_parser.h:494:22: performance: Function parameter 's' should be passed by const reference. [passedByValue]
int findLabel(string s, parsedLines *asm_parsed)
                     ^
src/execute.h:487:29: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
    int _run(vector<string> args, bool second_core, int core, Arguments arguments)
                            ^
src/execute.h:487:73: performance: Function parameter 'arguments' should be passed by const reference. [passedByValue]
    int _run(vector<string> args, bool second_core, int core, Arguments arguments)
                                                                        ^
src/execute.h:582:25: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
void executeOnly(string prog)
                        ^
src/execute.h:594:25: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void execute(string prog)
                        ^
src/execute.h:607:25: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void execute(string prog, Arguments arguments)
                        ^
src/execute.h:624:31: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void executeAsTask(string prog, int core, Arguments arguments)
                              ^
src/execute.h:645:31: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void executeAsTask(string prog, Arguments arguments)
                              ^
src/execute.h:645:47: performance: Function parameter 'arguments' should be passed by const reference. [passedByValue]
    void executeAsTask(string prog, Arguments arguments)
                                              ^
src/execute.h:649:31: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void executeAsTask(string prog)
                              ^
src/execute.h:655:31: performance: Function parameter 'prog' should be passed by const reference. [passedByValue]
    void executeAsTask(string prog, int core)
                              ^
src/execute.h:758:39: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void addExe(Executable df, string name)
                                      ^
src/execute.h:775:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void execute(string name)
                        ^
src/execute.h:786:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void execute(string name, string function)
                        ^
src/execute.h:797:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void execute(string name, Arguments arguments)
                        ^
src/execute.h:809:25: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void execute(string name, string function, Arguments arguments)
                        ^
src/execute.h:820:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name, Arguments arguments)
                              ^
src/execute.h:831:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name)
                              ^
src/execute.h:843:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name, string function, Arguments arguments)
                              ^
src/execute.h:854:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name, string function)
                              ^
src/execute.h:865:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name, int core, Arguments args)
                              ^
src/execute.h:876:31: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void executeAsTask(string name, int core)
                              ^
src/execute.h:887:22: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void kill(string name)
                     ^
src/execute.h:918:22: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    void free(string name)
                     ^
src/execute.h:959:39: performance: Function parameter 'name' should be passed by const reference. [passedByValue]
    exe_info getExecutableInfo(string name)
                                      ^
src/asm_struct_enum.h:19:13: performance: Function parameter 'def' should be passed by const reference. [passedByValue]
    Stack(T def)
            ^
src/ESPLiveScript.h:233:13: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
            pushToConsole(Error.error_message.c_str(), true);
            ^
src/ESPLiveScript.h:292:13: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
            pushToConsole(bin.error.error_message.c_str(), true);
            ^
src/ESPLiveScript.h:319:17: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
                pushToConsole(_executecmd.error.error_message.c_str(), true);
                ^
src/NodeToken.h:1265:17: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                {
                ^
src/NodeToken.h:1290:17: style: Consider using std::any_of algorithm instead of a raw loop. [useStlAlgorithm]
                {
                ^
src/asm_external.h:64:30: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_external.h:64:30: error: Uninitialized struct member: asmex.offset [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_external.h:75:30: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_external.h:75:30: error: Uninitialized struct member: asmex.offset [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_external.h:85:30: error: Uninitialized struct member: asmex.ptr [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_external.h:85:30: error: Uninitialized struct member: asmex.offset [uninitStructMember]
    external_links.push_back(asmex);
                             ^
src/asm_parser.h:163:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:171:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:163:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:171:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:197:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:205:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:197:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:205:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:231:25: error: Uninitialized struct member: error.line [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:239:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:231:25: error: Uninitialized struct member: error.pos [uninitStructMember]
            res.error = error;
                        ^
src/asm_parser.h:239:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:263:23: error: Uninitialized struct member: error.line [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:271:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:263:23: error: Uninitialized struct member: error.pos [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:271:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:295:23: error: Uninitialized struct member: error.line [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:303:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:295:23: error: Uninitialized struct member: error.pos [uninitStructMember]
          res.error = error;
                      ^
src/asm_parser.h:303:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:322:19: error: Uninitialized struct member: error.line [uninitStructMember]
      res.error = error;
                  ^
src/asm_parser.h:328:17: error: Uninitialized struct member: error.line [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:322:19: error: Uninitialized struct member: error.pos [uninitStructMember]
      res.error = error;
                  ^
src/asm_parser.h:328:17: error: Uninitialized struct member: error.pos [uninitStructMember]
    res.error = error;
                ^
src/asm_parser.h:1222:15: error: Uninitialized struct member: err.line [uninitStructMember]
  asm_Error = err;
              ^
src/asm_parser.h:1222:15: error: Uninitialized struct member: err.pos [uninitStructMember]
  asm_Error = err;
              ^
src/execute.h:972:16: error: Uninitialized variable: inf [uninitvar]
        return inf;
               ^
src/execute.h:964:15: note: Assuming condition is false
        if (f != NULL)
              ^
src/execute.h:972:16: note: Uninitialized variable: inf
        return inf;
               ^
src/execute.h:979:24: error: Uninitialized variable: inf [uninitvar]
                return inf;
                       ^
src/NodeToken.h:619:19: style: Variable 'nd.parent' is assigned a value that is never used. [unreadVariable]
        nd.parent = this;
                  ^
src/NodeToken.h:1102:15: style: Unused variable: tocmp [unusedVariable]
        char *tocmp;
              ^
src/NodeToken.h:1129:15: style: Unused variable: tocmp [unusedVariable]
        char *tocmp;
              ^
src/NodeToken.h:2257:17: style: Variable 'body' is assigned a value that is never used. [unreadVariable]
    string body = "";
                ^
src/NodeToken.h:2617:13: style: Variable 'sav' is assigned a value that is never used. [unreadVariable]
    int sav = 9;
            ^
src/NodeToken.h:3199:17: style: Variable 'nbfloat' is assigned a value that is never used. [unreadVariable]
    int nbfloat = 0;
                ^
src/NodeToken.h:3716:17: style: Variable 'body' is assigned a value that is never used. [unreadVariable]
    string body = "";
                ^
src/NodeToken.h:3834:18: style: Variable 't' is assigned a value that is never used. [unreadVariable]
    NodeToken *t = nd;
                 ^
src/NodeToken.h:4036:19: style: Variable '__num' is assigned a value that is never used. [unreadVariable]
            __num = 0;
                  ^
src/NodeToken.h:4182:17: style: Variable 'body' is assigned a value that is never used. [unreadVariable]
    string body = "";
                ^
src/NodeToken.h:4341:17: style: Variable 'body' is assigned a value that is never used. [unreadVariable]
    string body = "";
                ^
src/asm_parser.h:82:18: style: Variable 'add_size' is assigned a value that is never used. [unreadVariable]
    int add_size = 0;
                 ^
src/asm_parser.h:1770:9: style: Unused variable: textptr2 [unusedVariable]
  char *textptr2;
        ^
src/ESPLiveScript.h:3086:23: style: Variable 'memberpos' is assigned a value that is never used. [unreadVariable]
        int memberpos = 0;
                      ^
src/ESPLiveScript.h:3087:20: style: Variable '_start' is assigned a value that is never used. [unreadVariable]
        int _start = 0;
                   ^
src/ESPLiveScript.h:3088:18: style: Variable '_pos' is assigned a value that is never used. [unreadVariable]
        int _pos = 0;
                 ^
main.cpp:15:17: style: Variable 'exec' is assigned a value that is never used. [unreadVariable]
 Executable exec=_parser.parseScript(&script);
                ^
src/asm_struct_enum.h:219:13: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
            _it--;
            ^
src/asm_struct_enum.h:310:9: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        _it++;
        ^
src/asm_struct_enum.h:334:80: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        for (vector<char *>::iterator it = _texts.begin(); it != _texts.end(); it++)
                                                                               ^
src/asm_struct_enum.h:433:13: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
            _it--;
            ^
src/tokenizer.h:824:17: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
                it--;
                ^
src/tokenizer.h:848:9: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        it++;
        ^
src/tokenizer.h:858:82: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        for (vector<char *>::iterator _it = script.begin(); _it != script.end(); _it++)
                                                                                 ^
src/tokenizer.h:873:13: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
            it++;
            ^
src/asm_external.h:90:91: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
     for(vector<asm_external>::iterator it=external_links.begin();it<external_links.end();it++)
                                                                                          ^
src/NodeToken.h:1570:103: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
        for (vector<NodeToken *>::iterator it = __nd->children->begin(); it != __nd->children->end(); it++)
                                                                                                      ^
src/asm_parser.h:112:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = _asm_parsed.begin(); it != _asm_parsed.end(); it++)
                                                                                                ^
src/asm_parser.h:130:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = _asm_parsed.begin(); it != _asm_parsed.end(); it++)
                                                                                                ^
src/asm_parser.h:498:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                                ^
src/asm_parser.h:516:95: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                              ^
src/asm_parser.h:1491:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                                ^
src/asm_parser.h:1558:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                                ^
src/asm_parser.h:1599:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                                ^
src/asm_parser.h:1641:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      it2++;
      ^
src/asm_parser.h:1653:97: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
  for (vector<result_parse_line *>::iterator it = asm_parsed->begin(); it != asm_parsed->end(); it++)
                                                                                                ^
src/asm_parser.h:1725:7: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
      it2++;
      ^
src/execute.h:906:104: performance: Prefer prefix ++/-- operators for non-primitive types. [postfixOperator]
            for (vector<Executable>::iterator it = _scExecutables.begin(); it != _scExecutables.end(); it++)
                                                                                                       ^
src/NodeToken.h:146:18: information: --check-library: Function displayStat() should have <noreturn> configuration [checkLibraryNoReturn]
    displayStat();
                 ^
src/NodeToken.h:20:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole(str, force);
          ^
src/asm_parser.h:1340:9: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
  LedOS.pushToConsole(_d);
        ^
src/asm_parser.h:1357:9: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
  LedOS.pushToConsole(d);
        ^
src/asm_parser.h:2146:9: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
  LedOS.pushToConsole(s, false);
        ^
src/execute.h:365:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Something Already running kill it first ...", true);
                  ^
src/execute.h:391:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Halting the program ...", true);
                  ^
src/execute.h:410:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Program Halted.", true);
                  ^
src/execute.h:441:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Stopping the program ...", true);
                  ^
src/execute.h:469:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Program stopped.", true);
                  ^
src/execute.h:527:23: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
                LedOS.pushToConsole("too many programs at once", true);
                      ^
src/execute.h:540:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Execution on going CTRL + k to stop", true);
                  ^
src/execute.h:548:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Nothing to execute.", true);
                  ^
src/ESPLiveScript.h:3595:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Something Already running kill it first ...");
                  ^
src/ESPLiveScript.h:3616:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(config.ENDLINE);
        ^
src/ESPLiveScript.h:3617:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
        ^
src/ESPLiveScript.h:3617:21: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
                    ^
src/ESPLiveScript.h:3659:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("Compiling ...", true);
              ^
src/ESPLiveScript.h:3666:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("filename missing ...", true);
              ^
src/ESPLiveScript.h:3687:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Something Already running kill it first ...");
                  ^
src/ESPLiveScript.h:3713:17: information: --check-library: There is no matching configuration for function Serial::printf() [checkLibraryFunction]
         Serial.printf("oioioioe");
                ^
src/ESPLiveScript.h:3727:27: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
                    LedOS.pushToConsole("***********START RUN *********");
                          ^
src/ESPLiveScript.h:3733:25: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
                        _push(config.ENDLINE);
                        ^
src/ESPLiveScript.h:3734:25: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
                        _push(cons->prompt(cons).c_str());
                        ^
src/ESPLiveScript.h:3734:37: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
                        _push(cons->prompt(cons).c_str());
                                    ^
src/ESPLiveScript.h:3739:27: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
                    LedOS.pushToConsole("Start program", true);
                          ^
src/ESPLiveScript.h:3742:27: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
                    LedOS.pushToConsole("Execution done.", true);
                          ^
src/ESPLiveScript.h:3749:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("filename missing ...", true);
              ^
src/ESPLiveScript.h:3756:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole("Something Already running kill it first ...");
              ^
src/ESPLiveScript.h:3763:11: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
    LedOS.pushToConsole("Compiling ...", true);
          ^
src/ESPLiveScript.h:3782:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("***********START RUN *********");
                  ^
src/ESPLiveScript.h:3787:17: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
                _push(config.ENDLINE);
                ^
src/ESPLiveScript.h:3788:17: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
                _push(cons->prompt(cons).c_str());
                ^
src/ESPLiveScript.h:3788:29: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
                _push(cons->prompt(cons).c_str());
                            ^
src/ESPLiveScript.h:3793:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Start program", true);
                  ^
src/ESPLiveScript.h:3796:19: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
            LedOS.pushToConsole("Execution done.", true);
                  ^
src/ESPLiveScript.h:3801:15: information: --check-library: There is no matching configuration for function LedOS::pushToConsole() [checkLibraryFunction]
        LedOS.pushToConsole(SCExecutable.error.error_message, true);
              ^
src/ESPLiveScript.h:3818:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(config.ENDLINE);
        ^
src/ESPLiveScript.h:3819:9: information: --check-library: There is no matching configuration for function _push() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
        ^
src/ESPLiveScript.h:3819:21: information: --check-library: There is no matching configuration for function Console::prompt() [checkLibraryFunction]
        _push(cons->prompt(cons).c_str());
                    ^
src/ESPLiveScript.h:3834:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("compile", parse_c, "Compile and run a program add '&' for run on the second core");
              ^
src/ESPLiveScript.h:3835:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("comp", compile_c, "Compile  a program");
              ^
src/ESPLiveScript.h:3836:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("createbin", saveBin, "Compile  a program into binary");
              ^
src/ESPLiveScript.h:3837:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("executebin", binload, "executebin");
              ^
src/ESPLiveScript.h:3838:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("displaybin", displaybin, "displaybin");
              ^
src/ESPLiveScript.h:3839:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("./", binload, "executebin");
              ^
src/ESPLiveScript.h:3840:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("list", listExec, "list the compiled programs");
              ^
src/ESPLiveScript.h:3841:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("free", free, "free the binary free x will free the program with handle x");
              ^
src/ESPLiveScript.h:3842:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("run", run, "Run an already compiled program (always second Core) run x run program with handle x");
              ^
src/ESPLiveScript.h:3843:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("kill", kill, "Stop a running program kill x kill program with handle x");
              ^
src/ESPLiveScript.h:3844:15: information: --check-library: There is no matching configuration for function LedOS::addKeywordCommand() [checkLibraryFunction]
        LedOS.addKeywordCommand("parseasm", parseasm, "Parse assembly program");
              ^
src/ESPLiveScript.h:3845:15: information: --check-library: There is no matching configuration for function LedOS::addEscCommand() [checkLibraryFunction]
        LedOS.addEscCommand(18, parsec_cEsc, "Compile and execute a program (always second Core)");
              ^
src/ESPLiveScript.h:3846:15: information: --check-library: There is no matching configuration for function LedOS::addEscCommand() [checkLibraryFunction]
        LedOS.addEscCommand(11, kill_cEsc, "Stop a running program");
              ^
src/ESPLiveScript.h:4034:15: information: --check-library: There is no matching configuration for function LedOS::addHightLightinf() [checkLibraryFunction]
        LedOS.addHightLightinf("sc", formatLine, formatInit, formatLine);
              ^
src/ESPLiveScript.h:3538:65: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole("Nothing is currently running.", true);
                                                                ^
src/ESPLiveScript.h:3596:29: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
            kill(cons, args);
                            ^
src/ESPLiveScript.h:3617:42: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
        _push(cons->prompt(cons).c_str());
                                         ^
src/ESPLiveScript.h:3632:116: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        pushToConsole(string_format("Compiling done. Handle number:%d", scriptRuntime._scExecutables.size()), true);
                                                                                                                   ^
src/ESPLiveScript.h:3636:51: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        pushToConsole(_scExec.error.error_message);
                                                  ^
src/ESPLiveScript.h:3663:25: information: --check-library: Function freeBinary() should have <noreturn> configuration [checkLibraryNoReturn]
        freeBinary(&bin);
                        ^
src/ESPLiveScript.h:3675:25: information: --check-library: Function freeBinary() should have <noreturn> configuration [checkLibraryNoReturn]
        freeBinary(&bin);
                        ^
src/ESPLiveScript.h:3689:26: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
            kill(cons, k);
                         ^
src/ESPLiveScript.h:3715:73: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
            pushToConsole(_executecmd.error.error_message.c_str(), true);
                                                                        ^
src/ESPLiveScript.h:3734:58: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
                        _push(cons->prompt(cons).c_str());
                                                         ^
src/ESPLiveScript.h:3758:22: information: --check-library: Function kill() should have <noreturn> configuration [checkLibraryNoReturn]
        kill(cons, k);
                     ^
src/ESPLiveScript.h:3788:50: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
                _push(cons->prompt(cons).c_str());
                                                 ^
src/ESPLiveScript.h:3819:42: information: --check-library: Function _push() should have <noreturn> configuration [checkLibraryNoReturn]
        _push(cons->prompt(cons).c_str());
                                         ^
src/NodeToken.h:1547:16: style: Local variable 'p' shadows outer variable [shadowVariable]
    NodeToken *p = current_node;
               ^
src/ESPLiveScript.h:3525:8: note: Shadowed declaration
Parser p = Parser();
       ^
src/NodeToken.h:1547:16: note: Shadow variable
    NodeToken *p = current_node;
               ^
src/NodeToken.h:4790:40: style: Local variable 'p' shadows outer variable [shadowVariable]
                        vector<string> p = split(d[1], ",");
                                       ^
src/ESPLiveScript.h:3525:8: note: Shadowed declaration
Parser p = Parser();
       ^
src/NodeToken.h:4790:40: note: Shadow variable
                        vector<string> p = split(d[1], ",");
                                       ^
src/ESPLiveScript.h:3547:33: performance: Function parameter 'variables' should be passed by const reference. [passedByValue]
Arguments parseInputArgs(string variables)
                                ^
src/ESPLiveScript.h:3620:45: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void parseasm(Console *cons, vector<string> args)
                                            ^
src/ESPLiveScript.h:3623:46: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void compile_c(Console *cons, vector<string> args)
                                             ^
src/ESPLiveScript.h:3823:45: performance: Function parameter 'args' should be passed by const reference. [passedByValue]
void listExec(Console *cons, vector<string> args)
                                            ^
src/ESPLiveScript.h:3699:13: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
            pushToConsole(bin.error.error_message.c_str(), true);
            ^
src/ESPLiveScript.h:3715:13: performance: Passing the result of c_str() to a function that takes std::string as argument no. 1 is slow and redundant. [stlcstrParam]
            pushToConsole(_executecmd.error.error_message.c_str(), true);
            ^
src/ESPLiveScript.h:362:16: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            sc = sc + "\n" + s;
               ^
src/ESPLiveScript.h:376:16: style: Consider using std::accumulate algorithm instead of a raw loop. [useStlAlgorithm]
            sc = sc + "\n" + s;
               ^
src/ESPLiveScript.h:3666:58: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        LedOS.pushToConsole("filename missing ...", true);
                                                         ^
src/ESPLiveScript.h:3749:58: information: --check-library: Function pushToConsole() should have <noreturn> configuration [checkLibraryNoReturn]
        LedOS.pushToConsole("filename missing ...", true);
                                                         ^
src/ESPLiveScript.h:3691:24: style: Variable 'othercore' is assigned a value that is never used. [unreadVariable]
        bool othercore = false;
                       ^
src/asm_struct_enum.h:273:17: style: Condition '!isReused(0)' is always true [knownConditionTrueFalse]
            if (!isReused(0))
                ^
src/asm_struct_enum.h:112:8: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
       for (int i =  _texts.size()-1; i >=0; i--)
       ^
src/asm_struct_enum.h:407:9: style:inconclusive: Statements following return, break, continue, goto or throw will never be executed. [unreachableCode]
        if (pos < 0 or pos >= _texts.size())
        ^
nofile:0:0: information: Cppcheck cannot find all the include files (use --check-config for details) [missingInclude]

